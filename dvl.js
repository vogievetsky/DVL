// Generated by CoffeeScript 1.6.2
(function() {
  
function lift(fn) {
  var fn = arguments[0];
  if ('function' !== typeof fn) throw new TypeError();

  return function(/* args: to fn */) {
    var args = Array.prototype.slice.call(arguments),
        n = args.length,
        i;

    for (i = 0; i < n; i++) {
      if ('function' === typeof args[i]) {
        return function(/* args2 to function wrapper */) {
          var args2 = Array.prototype.slice.call(arguments),
              reduced = [],
              i, v;

          for (i = 0; i < n; i++) {
            v = args[i];
            reduced.push('function' === typeof v ? v.apply(this, args2) : v);
          }

          return fn.apply(null, reduced);
        };
      }
    }

    // Fell through so there are no functions in the arguments to fn -> call it!
    return fn.apply(null, args);
  };
}
;
  var DVLBlock, DVLConst, DVLVar, DVLWorker, PriorityQueue, Set, changedInNotify, clipId, collect_notify, curBlock, curCollectListener, curNotifyListener, default_compare, dvl, end_notify_collect, getBase, init_notify, lastNotifyRun, levelPriorityQueue, nextObjId, sortGraph, start_notify_collect, toNotify, uniqById, variables, within_notify, workers,
    __slice = [].slice,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  PriorityQueue = (function() {
    function PriorityQueue(key) {
      this.key = key;
      this.nodes_ = [];
    }

    PriorityQueue.prototype.length = function() {
      return this.nodes_.length;
    };

    PriorityQueue.prototype.push = function(node) {
      var nodes;

      nodes = this.nodes_;
      nodes.push(node);
      this.moveUp_(nodes.length - 1);
      return this;
    };

    PriorityQueue.prototype.shift = function() {
      var count, nodes, rootNode;

      nodes = this.nodes_;
      count = nodes.length;
      rootNode = nodes[0];
      if (count <= 0) {
        return void 0;
      } else if (count === 1) {
        nodes.pop();
      } else {
        nodes[0] = nodes.pop();
        this.moveDown_(0);
      }
      return rootNode;
    };

    PriorityQueue.prototype.moveDown_ = function(index) {
      var count, key, leftChildIndex, node, nodes, rightChildIndex, smallerChildIndex;

      nodes = this.nodes_;
      key = this.key;
      count = nodes.length;
      node = nodes[index];
      while (index < (count >> 1)) {
        leftChildIndex = index * 2 + 1;
        rightChildIndex = leftChildIndex + 1;
        smallerChildIndex = rightChildIndex < count && nodes[rightChildIndex][key] < nodes[leftChildIndex][key] ? rightChildIndex : leftChildIndex;
        if (nodes[smallerChildIndex][key] > node[key]) {
          break;
        }
        nodes[index] = nodes[smallerChildIndex];
        index = smallerChildIndex;
      }
      nodes[index] = node;
    };

    PriorityQueue.prototype.moveUp_ = function(index) {
      var key, node, nodes, parentIndex;

      nodes = this.nodes_;
      key = this.key;
      node = nodes[index];
      while (index > 0) {
        parentIndex = (index - 1) >> 1;
        if (nodes[parentIndex][key] > node[key]) {
          nodes[index] = nodes[parentIndex];
          index = parentIndex;
        } else {
          break;
        }
      }
      nodes[index] = node;
    };

    return PriorityQueue;

  })();

  dvl = function(value) {
    return new DVLVar(value);
  };

  dvl.version = '1.2.1';

  this.dvl = dvl;

  if (typeof module !== 'undefined' && module.exports) {
    module.exports = dvl;
    dvl.dvl = dvl;
  }

  dvl.typeOf = (function() {
    var toString;

    toString = Object.prototype.toString;
    return function(v) {
      var type;

      type = toString.call(v);
      return type.substring(8, type.length - 1).toLowerCase();
    };
  })();

  dvl.util = {
    strObj: function(obj) {
      var k, keys, str, type, _i, _len;

      type = dvl.typeOf(obj);
      if (type === 'object' || type === 'array') {
        str = [];
        keys = [];
        for (k in obj) {
          if (!obj.hasOwnProperty(k)) {
            continue;
          }
          keys.push(k);
        }
        keys.sort();
        for (_i = 0, _len = keys.length; _i < _len; _i++) {
          k = keys[_i];
          str.push(k, dvl.util.strObj(obj[k]));
        }
        return str.join('|');
      }
      if (type === 'function') {
        return '&';
      }
      return String(obj);
    },
    uniq: function(array) {
      var a, seen, uniq, _i, _len;

      seen = {};
      uniq = [];
      for (_i = 0, _len = array.length; _i < _len; _i++) {
        a = array[_i];
        if (!seen[a]) {
          uniq.push(a);
        }
        seen[a] = 1;
      }
      return uniq;
    },
    crossDomainPost: function(url, params) {
      var clean, frame, inputs, k, post_process, v;

      frame = d3.select('body').append('iframe').style('display', 'none');
      clean = function(d) {
        return d.replace(/'/g, "\\'");
      };
      inputs = [];
      for (k in params) {
        v = params[k];
        inputs.push("<input name='" + k + "' value='" + (clean(v)) + "'/>");
      }
      post_process = frame.node().contentWindow.document;
      post_process.open();
      post_process.write("<form method='POST' action='" + url + "'>" + (inputs.join('')) + "</form>");
      post_process.write("<script>window.onload=function(){document.forms[0].submit();}</script>");
      post_process.close();
      setTimeout(frame.remove, 800);
    },
    isEqual: function(a, b, cmp) {
      var aKeys, atype, bKeys, btype, c, k, _i, _len;

      if (a === b) {
        return true;
      }
      atype = dvl.typeOf(a);
      btype = dvl.typeOf(b);
      if (atype !== btype) {
        return false;
      }
      if ((!a && b) || (a && !b)) {
        return false;
      }
      if (atype === 'date') {
        return a.getTime() === b.getTime();
      }
      if (a !== a && b !== b) {
        return false;
      }
      if (atype === 'regexp') {
        return a.source === b.source && a.global === b.global && a.ignoreCase === b.ignoreCase && a.multiline === b.multiline;
      }
      if (!(atype === 'object' || atype === 'array')) {
        return false;
      }
      if (cmp) {
        for (_i = 0, _len = cmp.length; _i < _len; _i++) {
          c = cmp[_i];
          if ((c.a === a && c.b === b) || (c.a === b && c.b === a)) {
            return true;
          }
        }
      }
      if ((a.length != null) && a.length !== b.length) {
        return false;
      }
      aKeys = [];
      for (k in a) {
        aKeys.push(k);
      }
      bKeys = [];
      for (k in b) {
        bKeys.push(k);
      }
      if (aKeys.length !== bKeys.length) {
        return false;
      }
      cmp = cmp ? cmp.slice() : [];
      cmp.push({
        a: a,
        b: b
      });
      for (k in a) {
        if (!((b[k] != null) && dvl.util.isEqual(a[k], b[k], cmp))) {
          return false;
        }
      }
      return true;
    },
    clone: function(obj) {
      var k, ret, t, v;

      t = dvl.typeOf(obj);
      switch (t) {
        case 'array':
          return obj.slice();
        case 'object':
          ret = {};
          for (k in obj) {
            v = obj[k];
            ret[k] = v;
          }
          return ret;
        case 'date':
          return new Date(obj.getTime());
        default:
          return obj;
      }
    },
    escapeHTML: function(str) {
      return String(str).replace(/&/g, '&amp;').replace(/>/g, '&gt;').replace(/</g, '&lt;').replace(/"/g, '&quot;');
    }
  };

  Set = (function() {
    function Set() {
      this.map = {};
      this.len = 0;
    }

    Set.prototype.valueOf = function() {
      return this.map;
    };

    Set.prototype.length = function() {
      return this.len;
    };

    Set.prototype.add = function(obj) {
      if (!this.map.hasOwnProperty(obj.id)) {
        this.map[obj.id] = obj;
        this.len++;
      }
      return this;
    };

    Set.prototype.remove = function(obj) {
      if (this.map.hasOwnProperty(obj.id)) {
        delete this.map[obj.id];
        this.len--;
      }
      return this;
    };

    return Set;

  })();

  nextObjId = 1;

  variables = [];

  workers = [];

  curBlock = null;

  default_compare = function(a, b) {
    return a === b;
  };

  DVLConst = (function() {
    function DVLConst(val) {
      this.v = val != null ? val : null;
      this.changed = false;
      return this;
    }

    DVLConst.prototype.toString = function() {
      var tag;

      tag = this.n ? this.n + ':' : '';
      return "[" + this.tag + this.v + "]";
    };

    DVLConst.prototype.value = function(val) {
      if (arguments.length) {
        return this;
      } else {
        return this.v;
      }
    };

    DVLConst.prototype.set = function() {
      return this;
    };

    DVLConst.prototype.lazyValue = function() {
      return this;
    };

    DVLConst.prototype.update = function() {
      return this;
    };

    DVLConst.prototype.get = function() {
      return this.v;
    };

    DVLConst.prototype.getPrev = function() {
      return this.v;
    };

    DVLConst.prototype.hasChanged = function() {
      return this.changed;
    };

    DVLConst.prototype.resetChanged = function() {
      return null;
    };

    DVLConst.prototype.notify = function() {
      return null;
    };

    DVLConst.prototype.discard = function() {
      return null;
    };

    DVLConst.prototype.name = function() {
      var _ref;

      if (arguments.length === 0) {
        return (_ref = this.n) != null ? _ref : '<anon_const>';
      } else {
        this.n = arguments[0];
        return this;
      }
    };

    DVLConst.prototype.compare = function() {
      if (arguments.length) {
        return this;
      } else {
        return default_compare;
      }
    };

    DVLConst.prototype.verify = function() {
      if (arguments.length) {
        return this;
      } else {
        return null;
      }
    };

    DVLConst.prototype.apply = function(fn) {
      return dvl.apply(this, fn);
    };

    DVLConst.prototype.applyValid = function(fn) {
      return dvl.applyValid(this, fn);
    };

    DVLConst.prototype.applyAlways = function(fn) {
      return dvl.applyAlways(this, fn);
    };

    DVLConst.prototype.pluck = function(prop) {
      return dvl.apply(this, function(d) {
        return d[prop];
      });
    };

    DVLConst.prototype.pluckEx = function(prop) {
      return dvl.apply(this, function(d) {
        return d[prop]();
      });
    };

    DVLConst.prototype.project = function(fns) {
      return dvl["const"]((this.v != null) && (fns != null ? fns.down : void 0) ? fns.down.call(null, this.v) : null);
    };

    return DVLConst;

  })();

  DVLVar = (function() {
    function DVLVar(val) {
      this.v = val != null ? val : null;
      this.id = nextObjId++;
      this.prev = null;
      this.changed = false;
      this.vgen = void 0;
      this.vgenPrev = void 0;
      this.vlen = -1;
      this.lazy = null;
      this.listeners = [];
      this.changers = [];
      this.compareFn = default_compare;
      variables.push(this);
      if (curBlock) {
        curBlock.addMemeber(this);
      }
      return this;
    }

    DVLVar.prototype.resolveLazy = function() {
      if (this.lazy) {
        this.prev = this.v;
        this.v = this.lazy();
        this.lazy = null;
      }
    };

    DVLVar.prototype.toString = function() {
      var tag;

      tag = this.n ? this.n + ':' : '';
      return "[" + this.tag + this.val + "]";
    };

    DVLVar.prototype.hasChanged = function() {
      if (this.proj) {
        return this.proj.parent.hasChanged();
      } else {
        return this.changed;
      }
    };

    DVLVar.prototype.resetChanged = function() {
      this.changed = false;
      return this;
    };

    DVLVar.prototype.value = function(val) {
      var fnDown, parent, pv, _ref;

      if (arguments.length) {
        val = val != null ? val : null;
        if (val !== null && this.verifyFn && !this.verifyFn.call(this, val)) {
          return this;
        }
        if (this.compareFn && this.compareFn.call(this, val, this.value())) {
          return this;
        }
        this.set(val);
        dvl.notify(this);
        return this;
      } else {
        if (this.proj) {
          _ref = this.proj, parent = _ref.parent, fnDown = _ref.fnDown;
          pv = parent.value();
          this.v = pv != null ? fnDown.call(this.v, pv) : null;
        } else {
          this.resolveLazy();
        }
        return this.v;
      }
    };

    DVLVar.prototype.set = function(val) {
      var fnUp, parent, _ref;

      val = val != null ? val : null;
      if (this.proj) {
        _ref = this.proj, parent = _ref.parent, fnUp = _ref.fnUp;
        parent.value(fnUp.call(parent.value(), val));
        return this;
      }
      if (!this.changed) {
        this.prev = this.v;
      }
      this.v = val;
      this.vgen = void 0;
      this.changed = true;
      this.lazy = null;
      return this;
    };

    DVLVar.prototype.lazyValue = function(fn) {
      this.lazy = fn;
      this.changed = true;
      dvl.notify(this);
      return this;
    };

    DVLVar.prototype.update = function(val) {
      if (!dvl.util.isEqual(val, this.v)) {
        this.set(val);
        dvl.notify(this);
      }
      return this;
    };

    DVLVar.prototype.get = function() {
      return this.value();
    };

    DVLVar.prototype.getPrev = function() {
      this.resolveLazy();
      if (this.prev && this.changed) {
        return this.prev;
      } else {
        return this.v;
      }
    };

    DVLVar.prototype.notify = function() {
      return dvl.notify(this);
    };

    DVLVar.prototype.discard = function() {
      if (this.listeners.length > 0) {
        throw "Cannot remove variable " + this.id + " because it has listeners.";
      }
      if (this.changers.length > 0) {
        throw "Cannot remove variable " + this.id + " because it has changers.";
      }
      variables.splice(variables.indexOf(this), 1);
      return null;
    };

    DVLVar.prototype.name = function() {
      var _ref;

      if (arguments.length === 0) {
        return (_ref = this.n) != null ? _ref : '<anon>';
      } else {
        this.n = arguments[0];
        return this;
      }
    };

    DVLVar.prototype.compare = function() {
      if (arguments.length) {
        this.compareFn = arguments[0];
        return this;
      } else {
        return this.compareFn;
      }
    };

    DVLVar.prototype.verify = function() {
      if (arguments.length) {
        this.verifyFn = arguments[0];
        return this;
      } else {
        return this.verifyFn;
      }
    };

    DVLVar.prototype.apply = function(fn) {
      return dvl.apply(this, fn);
    };

    DVLVar.prototype.applyValid = function(fn) {
      return dvl.applyValid(this, fn);
    };

    DVLVar.prototype.applyAlways = function(fn) {
      return dvl.applyAlways(this, fn);
    };

    DVLVar.prototype.pluck = function(prop) {
      return dvl.apply(this, function(d) {
        return d[prop];
      });
    };

    DVLVar.prototype.pluckEx = function(prop) {
      return dvl.apply(this, function(d) {
        return d[prop]();
      });
    };

    DVLVar.prototype.project = function(fns) {
      var me, v;

      fns = dvl.wrap(fns);
      v = dvl();
      me = this;
      dvl.register({
        listen: fns,
        change: me,
        fn: function() {
          var _fns;

          _fns = fns.value();
          if (!_fns) {
            _fns = {
              down: function() {
                return null;
              },
              up: function() {}
            };
          }
          v.proj = {
            parent: me,
            fnDown: _fns.down,
            fnUp: _fns.up
          };
          me.notify();
        }
      });
      return v;
    };

    return DVLVar;

  })();

  getBase = function(v) {
    while (v.proj) {
      v = v.proj.parent;
    }
    return v;
  };

  dvl.def = function(value) {
    return new DVLVar(value);
  };

  dvl["const"] = function(value) {
    return new DVLConst(value);
  };

  dvl.knows = function(v) {
    return v instanceof DVLVar || v instanceof DVLConst;
  };

  DVLWorker = (function() {
    function DVLWorker(name, ctx, fn, listen, change) {
      var hasPrev, lvl, min, nextWorker, nwid, prevWorker, v, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref, _ref1, _ref2, _ref3, _ref4;

      this.name = name;
      this.ctx = ctx;
      this.fn = fn;
      this.listen = listen;
      this.change = change;
      this.id = nextObjId++;
      this.updates = new Set();
      this.level = workers.length;
      workers.push(this);
      hasPrev = false;
      _ref = this.listen;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        v = _ref[_i];
        v.listeners.push(this);
        _ref1 = v.changers;
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          prevWorker = _ref1[_j];
          prevWorker.updates.add(this);
          hasPrev = true;
        }
      }
      _ref2 = this.change;
      for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
        v = _ref2[_k];
        v.changers.push(this);
        _ref3 = v.listeners;
        for (_l = 0, _len3 = _ref3.length; _l < _len3; _l++) {
          nextWorker = _ref3[_l];
          this.updates.add(nextWorker);
        }
      }
      if (this.updates.length()) {
        min = Infinity;
        _ref4 = this.updates.valueOf();
        for (nwid in _ref4) {
          nextWorker = _ref4[nwid];
          lvl = nextWorker.level;
          if (lvl < min) {
            min = lvl;
          }
        }
        sortGraph(min);
      }
      if (curBlock) {
        curBlock.addMemeber(this);
      }
    }

    DVLWorker.prototype.addChange = function() {
      var nextWorker, updatesChanged, uv, v, _i, _j, _len, _len1, _ref;

      uv = uniqById(arguments);
      if (uv.length) {
        updatesChanged = false;
        for (_i = 0, _len = uv.length; _i < _len; _i++) {
          v = uv[_i];
          this.change.push(v);
          v.changers.push(this);
          _ref = v.listeners;
          for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
            nextWorker = _ref[_j];
            this.updates.add(nextWorker);
            updatesChanged = true;
          }
        }
        if (updatesChanged) {
          sortGraph();
        }
      }
      return this;
    };

    DVLWorker.prototype.addListen = function() {
      var changedSave, hasPrev, i, prevWorker, updatesChanged, uv, v, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref;

      uv = uniqById(arguments);
      if (uv.length) {
        updatesChanged = false;
        for (_i = 0, _len = uv.length; _i < _len; _i++) {
          v = uv[_i];
          this.listen.push(v);
          v.listeners.push(this);
          _ref = v.changers;
          for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
            prevWorker = _ref[_j];
            prevWorker.updates.add(this);
            updatesChanged = true;
            hasPrev = false;
          }
        }
        if (updatesChanged) {
          sortGraph();
        }
      }
      uv = uniqById(arguments, true);
      start_notify_collect(this);
      changedSave = [];
      for (_k = 0, _len2 = uv.length; _k < _len2; _k++) {
        v = uv[_k];
        changedSave.push(v.changed);
        v.changed = true;
      }
      this.fn.apply(this.ctx);
      for (i = _l = 0, _len3 = uv.length; _l < _len3; i = ++_l) {
        v = uv[i];
        v.changed = changedSave[i];
      }
      end_notify_collect();
      return this;
    };

    DVLWorker.prototype.discard = function() {
      var prevWorker, v, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref, _ref1, _ref2, _ref3;

      workers.splice(workers.indexOf(this), 1);
      _ref = this.listen;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        v = _ref[_i];
        _ref1 = v.changers;
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          prevWorker = _ref1[_j];
          prevWorker.updates.remove(this);
        }
      }
      _ref2 = this.change;
      for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
        v = _ref2[_k];
        v.changers.splice(v.changers.indexOf(this), 1);
      }
      _ref3 = this.listen;
      for (_l = 0, _len3 = _ref3.length; _l < _len3; _l++) {
        v = _ref3[_l];
        v.listeners.splice(v.listeners.indexOf(this), 1);
      }
      sortGraph();
      this.change = this.listen = this.updates = null;
    };

    return DVLWorker;

  })();

  dvl.register = function(_arg) {
    var c, change, changedSave, ctx, fn, i, l, listen, listenConst, name, noRun, v, worker, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _m;

    ctx = _arg.ctx, fn = _arg.fn, listen = _arg.listen, change = _arg.change, name = _arg.name, noRun = _arg.noRun;
    if (curNotifyListener) {
      throw new Error('cannot call register from within a notify');
    }
    if (typeof fn !== 'function') {
      throw new TypeError('fn must be a function');
    }
    if (dvl.typeOf(listen) !== 'array') {
      listen = [listen];
    }
    if (dvl.typeOf(change) !== 'array') {
      change = [change];
    }
    listenConst = [];
    if (listen) {
      for (_i = 0, _len = listen.length; _i < _len; _i++) {
        v = listen[_i];
        if (v instanceof DVLConst) {
          listenConst.push(v);
        }
      }
    }
    listen = uniqById(listen).map(getBase);
    change = uniqById(change).map(getBase);
    worker = new DVLWorker(name || 'fn', ctx, fn, listen, change);
    if (!noRun) {
      changedSave = [];
      for (i = _j = 0, _len1 = listen.length; _j < _len1; i = ++_j) {
        l = listen[i];
        changedSave[i] = l.changed;
        l.changed = true;
      }
      for (_k = 0, _len2 = listenConst.length; _k < _len2; _k++) {
        l = listenConst[_k];
        l.changed = true;
      }
      start_notify_collect(worker);
      fn.call(ctx);
      end_notify_collect();
      for (i = _l = 0, _len3 = changedSave.length; _l < _len3; i = ++_l) {
        c = changedSave[i];
        listen[i].changed = c;
      }
      for (_m = 0, _len4 = listenConst.length; _m < _len4; _m++) {
        l = listenConst[_m];
        l.changed = false;
      }
    }
    return worker;
  };

  DVLBlock = (function() {
    function DVLBlock(name, parent) {
      var _ref;

      this.name = name;
      this.parent = parent;
      this.owns = {};
      if ((_ref = this.parent) != null) {
        _ref.add(this);
      }
      return;
    }

    DVLBlock.prototype.addMemeber = function(thing) {
      this.owns[thing.id] = thing;
      return this;
    };

    DVLBlock.prototype.removeMemeber = function(thing) {
      delete this.owns[thing.id];
      return this;
    };

    DVLBlock.prototype.discard = function() {
      var d, _i, _len, _ref, _ref1;

      if ((_ref = this.parent) != null) {
        _ref.removeMemeber(this);
      }
      _ref1 = this.owns;
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        d = _ref1[_i];
        d.discard();
      }
    };

    return DVLBlock;

  })();

  dvl.blockFn = function() {
    var fn, name;

    switch (arguments.length) {
      case 1:
        fn = arguments[0];
        break;
      case 2:
        name = arguments[0], fn = arguments[1];
        break;
      default:
        throw "bad number of arguments";
    }
    return function() {
      var args, block, ret;

      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      block = new DVLBlock(name, curBlock);
      ret = fn.apply(this, args);
      curBlock = block.parent;
      return ret;
    };
  };

  dvl.block = function() {
    var block, fn, name;

    switch (arguments.length) {
      case 1:
        fn = arguments[0];
        break;
      case 2:
        name = arguments[0], fn = arguments[1];
        break;
      default:
        throw "bad number of arguments";
    }
    block = new DVLBlock(name, curBlock);
    fn.call(this);
    curBlock = block.parent;
    return block;
  };

  dvl.group = function(fn) {
    return function() {
      var captured_notifies, fnArgs;

      fnArgs = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      if (dvl.notify === init_notify) {
        captured_notifies = [];
        dvl.notify = function() {
          var args;

          args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
          Array.prototype.push.apply(captured_notifies, args);
        };
        fn.apply(this, fnArgs);
        dvl.notify = init_notify;
        init_notify.apply(dvl, captured_notifies);
      } else {
        fn.apply(this, fnArgs);
      }
    };
  };

  dvl.wrapConstIfNeeded = dvl.wrap = function(v, name) {
    if (v === void 0) {
      v = null;
    }
    if (dvl.knows(v)) {
      return v;
    } else {
      return dvl["const"](v).name(name);
    }
  };

  dvl.wrapVarIfNeeded = dvl.wrapVar = function(v, name) {
    if (v === void 0) {
      v = null;
    }
    if (dvl.knows(v)) {
      return v;
    } else {
      return dvl(v).name(name);
    }
  };

  dvl.valueOf = function(v) {
    if (dvl.knows(v)) {
      return v.value();
    } else {
      return v != null ? v : null;
    }
  };

  (function() {
    var nsId;

    nsId = 0;
    dvl.namespace = function(str) {
      if (str == null) {
        str = 'ns';
      }
      nsId++;
      return str + nsId;
    };
  })();

  uniqById = function(vs, allowConst) {
    var res, seen, v, _i, _len;

    res = [];
    if (vs) {
      seen = {};
      for (_i = 0, _len = vs.length; _i < _len; _i++) {
        v = vs[_i];
        if ((v != null) && (allowConst || (v.listeners && v.changers)) && !seen[v.id]) {
          seen[v.id] = true;
          res.push(v);
        }
      }
    }
    return res;
  };

  sortGraph = function(from) {
    var getInboundCount, i, ic, idPriorityQueue, inboundCount, isSource, j, level, nextWorker, nwid, prevWorker, v, worker, workerListen, workerListenLength, workersLength, _i, _len, _ref, _ref1, _sources;

    if (from == null) {
      from = 0;
    }
    idPriorityQueue = new PriorityQueue('id');
    getInboundCount = function(worker, from) {
      var count, prevWorker, seen, v, _i, _j, _len, _len1, _ref, _ref1;

      seen = {};
      count = 0;
      _ref = worker.listen;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        v = _ref[_i];
        _ref1 = v.changers;
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          prevWorker = _ref1[_j];
          if (from <= prevWorker.level && !seen[prevWorker.id]) {
            seen[prevWorker.id] = true;
            ++count;
          }
        }
      }
      return count;
    };
    inboundCount = {};
    _sources = [];
    i = from;
    workersLength = workers.length;
    while (i < workersLength) {
      worker = workers[i++];
      isSource = true;
      j = 0;
      workerListen = worker.listen;
      workerListenLength = workerListen.length;
      while (j < workerListenLength && isSource) {
        v = workerListen[j++];
        _ref = v.changers;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          prevWorker = _ref[_i];
          if (from <= prevWorker.level) {
            isSource = false;
            break;
          }
        }
      }
      if (isSource) {
        idPriorityQueue.push(worker);
      }
    }
    level = from;
    while (idPriorityQueue.length()) {
      worker = idPriorityQueue.shift();
      workers[worker.level = level++] = worker;
      _ref1 = worker.updates.valueOf();
      for (nwid in _ref1) {
        nextWorker = _ref1[nwid];
        ic = inboundCount[nwid] || getInboundCount(nextWorker, from);
        ic--;
        if (ic === 0) {
          idPriorityQueue.push(nextWorker);
        } else {
          inboundCount[nwid] = ic;
        }
      }
    }
    if (level !== workers.length) {
      throw new Error('there is a cycle');
    }
  };

  dvl.clearAll = function() {
    var v, worker, _i, _j, _len, _len1;

    for (_i = 0, _len = workers.length; _i < _len; _i++) {
      worker = workers[_i];
      worker.listen = worker.change = worker.updates = null;
    }
    for (_j = 0, _len1 = variables.length; _j < _len1; _j++) {
      v = variables[_j];
      v.listeners = v.changers = null;
    }
    nextObjId = 1;
    variables = [];
    workers = [];
  };

  levelPriorityQueue = new PriorityQueue('level');

  curNotifyListener = null;

  curCollectListener = null;

  changedInNotify = null;

  lastNotifyRun = null;

  toNotify = null;

  start_notify_collect = function(listener) {
    toNotify = [];
    curCollectListener = listener;
    dvl.notify = collect_notify;
  };

  end_notify_collect = function() {
    curCollectListener = null;
    dvl.notify = init_notify;
    dvl.notify.apply(null, toNotify);
    toNotify = null;
  };

  collect_notify = function() {
    var v, _i, _len;

    if (!curCollectListener) {
      throw 'bad stuff happened during a collect block';
    }
    for (_i = 0, _len = arguments.length; _i < _len; _i++) {
      v = arguments[_i];
      if (!(v instanceof DVLVar)) {
        continue;
      }
      v = getBase(v);
      if (__indexOf.call(curCollectListener.change, v) < 0) {
        throw "changed unregisterd object " + v.id;
      }
      toNotify.push(v);
    }
  };

  within_notify = function() {
    var l, v, _i, _j, _len, _len1, _ref;

    if (!curNotifyListener) {
      throw 'bad stuff happened within a notify block';
    }
    for (_i = 0, _len = arguments.length; _i < _len; _i++) {
      v = arguments[_i];
      if (!(v instanceof DVLVar)) {
        continue;
      }
      v = getBase(v);
      if (__indexOf.call(curNotifyListener.change, v) < 0) {
        throw "changed unregisterd object " + v.id;
      }
      changedInNotify.push(v);
      lastNotifyRun.push(v.id);
      _ref = v.listeners;
      for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
        l = _ref[_j];
        if (!l.visited) {
          levelPriorityQueue.push(l);
        }
      }
    }
  };

  init_notify = function() {
    var l, v, visitedListener, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref;

    if (curNotifyListener) {
      throw 'bad stuff happened init';
    }
    lastNotifyRun = [];
    visitedListener = [];
    changedInNotify = [];
    for (_i = 0, _len = arguments.length; _i < _len; _i++) {
      v = arguments[_i];
      if (!(v instanceof DVLVar)) {
        continue;
      }
      v = getBase(v);
      changedInNotify.push(v);
      lastNotifyRun.push(v.id);
      _ref = v.listeners;
      for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
        l = _ref[_j];
        levelPriorityQueue.push(l);
      }
    }
    dvl.notify = within_notify;
    while (levelPriorityQueue.length() > 0) {
      curNotifyListener = levelPriorityQueue.shift();
      if (curNotifyListener.visited) {
        continue;
      }
      curNotifyListener.visited = true;
      visitedListener.push(curNotifyListener);
      lastNotifyRun.push(curNotifyListener.id);
      curNotifyListener.fn.apply(curNotifyListener.ctx);
    }
    curNotifyListener = null;
    dvl.notify = init_notify;
    for (_k = 0, _len2 = changedInNotify.length; _k < _len2; _k++) {
      v = changedInNotify[_k];
      v.resetChanged();
    }
    for (_l = 0, _len3 = visitedListener.length; _l < _len3; _l++) {
      l = visitedListener[_l];
      l.visited = false;
    }
  };

  dvl.notify = init_notify;

  dvl.graphToDot = function(lastTrace, showId) {
    var color, dot, execOrder, fnName, id, k, l, level, levels, nameMap, pos, v, varName, w, worker, _i, _j, _k, _l, _len, _len1, _len2, _len3, _name, _ref, _ref1, _ref2;

    execOrder = {};
    if (lastTrace && lastNotifyRun) {
      for (pos in lastNotifyRun) {
        id = lastNotifyRun[pos];
        execOrder[id] = pos;
      }
    }
    nameMap = {};
    for (_i = 0, _len = workers.length; _i < _len; _i++) {
      worker = workers[_i];
      id = worker.id;
      fnName = id.replace(/\n/g, '');
      fnName = fnName + ' (' + worker.level + ')';
      fnName = '"' + fnName + '"';
      nameMap[id] = fnName;
    }
    for (v in variables) {
      id = v.id;
      varName = id.replace(/\n/g, '');
      varName = '"' + varName + '"';
      nameMap[id] = varName;
    }
    dot = [];
    dot.push('digraph G {');
    dot.push('  rankdir=LR;');
    levels = [];
    _ref = variables.valueOf();
    for (id in _ref) {
      v = _ref[id];
      color = execOrder[id] ? 'red' : 'black';
      dot.push("  " + nameMap[id] + " [color=" + color + "];");
    }
    for (k in workers) {
      l = workers[k];
      levels[_name = l.level] || (levels[_name] = []);
      levels[l.level].push(nameMap[l.id]);
      color = execOrder[l.id] ? 'red' : 'black';
      dot.push("  " + nameMap[l.id] + " [shape=box,color=" + color + "];");
      _ref1 = l.listen;
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        v = _ref1[_j];
        color = execOrder[v.id] && execOrder[l.id] ? 'red' : 'black';
        dot.push("  " + nameMap[v.id] + " -> " + nameMap[l.id] + " [color=" + color + "];");
      }
      _ref2 = l.change;
      for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
        w = _ref2[_k];
        color = execOrder[l.id] && execOrder[w.id] ? 'red' : 'black';
        dot.push("  " + nameMap[l.id] + " -> " + nameMap[w.id] + " [color=" + color + "];");
      }
    }
    for (_l = 0, _len3 = levels.length; _l < _len3; _l++) {
      level = levels[_l];
      dot.push('{ rank = same; ' + level.join('; ') + '; }');
    }
    dot.push('}');
    return dot.join('\n');
  };

  dvl.postGraph = function(file, showId) {
    var g;

    file || (file = 'dvl_graph');
    g = dvl.graphToDot(false, showId);
    dvl.util.crossDomainPost('http://localhost:8124/' + file, {
      graph: JSON.stringify(g)
    });
  };

  dvl.postLatest = function(file, showId) {
    var g;

    file || (file = 'dvl_graph_latest');
    g = dvl.graphToDot(true, showId);
    dvl.util.crossDomainPost('http://localhost:8124/' + file, {
      graph: JSON.stringify(g)
    });
  };

  dvl.zero = dvl["const"](0).name('zero');

  dvl["null"] = dvl["const"](null).name('null');

  dvl.ident = function(x) {
    return x;
  };

  dvl.identity = dvl["const"](dvl.ident).name('identity');

  dvl.acc = function(column) {
    var acc, makeAcc;

    column = dvl.wrap(column);
    acc = dvl().name("acc");
    makeAcc = function() {
      var col;

      col = column.value();
      if (col != null) {
        col = String(col.valueOf());
        return acc.value(function(d) {
          return d[col];
        });
      } else {
        return acc.value(null);
      }
    };
    dvl.register({
      fn: makeAcc,
      listen: [column],
      change: [acc],
      name: 'make_acc'
    });
    return acc;
  };

  dvl.debug = function() {
    var note, obj, print;

    print = function() {
      if (!(typeof console !== "undefined" && console !== null ? console.log : void 0)) {
        return;
      }
      console.log.apply(console, arguments);
      return arguments[0];
    };
    if (arguments.length === 1) {
      obj = dvl.wrap(arguments[0]);
      note = obj.name() + ':';
    } else {
      obj = dvl.wrap(arguments[1]);
      note = arguments[0];
    }
    dvl.register({
      listen: [obj],
      fn: function() {
        return print(note, obj.value());
      }
    });
    return obj;
  };

  dvl.apply = dvl.applyValid = function() {
    var allowNull, args, fn, invalid, out, update, _ref, _ref1;

    switch (arguments.length) {
      case 1:
        _ref = arguments[0], args = _ref.args, fn = _ref.fn, invalid = _ref.invalid, allowNull = _ref.allowNull, update = _ref.update;
        if (args === void 0 && !arguments[0].hasOwnProperty('args')) {
          args = [];
        }
        break;
      case 2:
        args = arguments[0], fn = arguments[1];
        break;
      case 3:
        args = arguments[0], (_ref1 = arguments[1], invalid = _ref1.invalid, allowNull = _ref1.allowNull, update = _ref1.update), fn = arguments[2];
        break;
      default:
        throw "incorect number of arguments";
    }
    fn = dvl.wrap(fn || dvl.identity);
    if (!Array.isArray(args)) {
      args = [args];
    }
    args = args.map(dvl.wrap);
    invalid = dvl.wrap(invalid != null ? invalid : null);
    out = dvl(invalid.value()).name('apply_valid_out');
    dvl.register({
      name: 'apply_fn',
      listen: args.concat([fn, invalid]),
      change: out,
      fn: function() {
        var a, f, nulls, r, send, v, _i, _len;

        f = fn.value();
        if (f == null) {
          return;
        }
        send = [];
        nulls = false;
        for (_i = 0, _len = args.length; _i < _len; _i++) {
          a = args[_i];
          v = a.value();
          if (v == null) {
            nulls = true;
          }
          send.push(v);
        }
        if (!nulls || allowNull) {
          r = f.apply(null, send);
          if (r === void 0) {
            return;
          }
        } else {
          r = invalid.value();
        }
        if (update) {
          out.update(r);
        } else {
          out.set(r).notify();
        }
      }
    });
    return out;
  };

  dvl.applyAlways = function() {
    var args, fn, out, update, _ref, _ref1;

    switch (arguments.length) {
      case 1:
        _ref = arguments[0], args = _ref.args, fn = _ref.fn, update = _ref.update;
        if (args === void 0 && !arguments[0].hasOwnProperty('args')) {
          args = [];
        }
        break;
      case 2:
        args = arguments[0], fn = arguments[1];
        break;
      case 3:
        args = arguments[0], (_ref1 = arguments[1], update = _ref1.update), fn = arguments[2];
        break;
      default:
        throw "incorect number of arguments";
    }
    fn = dvl.wrap(fn || dvl.identity);
    if (!Array.isArray(args)) {
      args = [args];
    }
    args = args.map(dvl.wrap);
    out = dvl().name('apply_valid_out');
    dvl.register({
      name: 'apply_fn',
      listen: args.concat([fn]),
      change: out,
      fn: function() {
        var a, f, r, send, _i, _len;

        f = fn.value();
        if (f == null) {
          return;
        }
        send = [];
        for (_i = 0, _len = args.length; _i < _len; _i++) {
          a = args[_i];
          send.push(a.value());
        }
        r = f.apply(null, send);
        if (r === void 0) {
          return;
        }
        if (update) {
          out.update(r);
        } else {
          out.set(r).notify();
        }
      }
    });
    return out;
  };

  dvl.random = function(options) {
    var gen, int, max, min, random, walk;

    min = options.min || 0;
    max = options.max || min + 10;
    int = options.integer;
    walk = options.walk;
    random = dvl((max - min) / 2, options.name || 'random');
    gen = function() {
      var r, scale;

      if (walk && walk > 0) {
        scale = walk * Math.abs(max - min);
        r = random.value() + scale * (2 * Math.random() - 1);
        if (r < min) {
          r = min;
        }
        if (max < r) {
          r = max;
        }
      } else {
        r = Math.random() * (max - min) + min;
      }
      if (int) {
        r = Math.floor(r);
      }
      random.set(r);
      return dvl.notify(random);
    };
    if (options.interval) {
      setInterval(gen, options.interval);
    }
    gen();
    return random;
  };

  dvl.arrayTick = function(data, options) {
    var gen, move, out, point;

    if (!data) {
      throw 'dvl.arrayTick: no data';
    }
    data = dvl.wrap(data);
    point = options.start || 0;
    move = options.move || 1;
    out = dvl(null, 'array_tick_data');
    gen = function() {
      var d, len, v;

      d = data.value();
      len = d.length;
      if (len > 0) {
        v = d[point % len];
        point = (point + move) % len;
        out.set(v);
        return dvl.notify(out);
      }
    };
    if (options.interval) {
      setInterval(gen, options.interval);
    }
    gen();
    return out;
  };

  dvl.recorder = function(options) {
    var array, data, fn, i, max, record;

    array = dvl.wrapVar(options.array || [], options.name || 'recorder_array').compare(false);
    data = options.data;
    fn = dvl.wrap(options.fn || dvl.identity);
    if (!dvl.knows(data)) {
      throw 'it does not make sense not to have data';
    }
    max = dvl.wrap(options.max || +Infinity);
    i = 0;
    record = function() {
      var d, m, o, _array;

      d = fn.value()(data.value());
      m = max.value();
      if (d != null) {
        if (options.value) {
          o = {};
          o[options.value] = d;
          d = o;
        }
        if (options.index) {
          d[options.index] = i;
        }
        if (options.timestamp) {
          d[options.timestamp] = new Date();
        }
        _array = array.value();
        _array.push(d);
        while (m < _array.length) {
          _array.shift();
        }
        array.value(_array);
        return i += 1;
      }
    };
    dvl.register({
      fn: record,
      listen: [data],
      change: [array],
      name: 'recorder'
    });
    return array;
  };

  (function() {
    var addHoock, inputChange, onHashChange, vars, worker;

    vars = [];
    inputChange = function() {
      var obj, v, _i, _len;

      obj = {};
      for (_i = 0, _len = vars.length; _i < _len; _i++) {
        v = vars[_i];
        obj[v.name] = v.object.value();
      }
      window.location.hash = dvl.urlHash.toHashString(obj);
    };
    onHashChange = function() {
      var obj, v, val, _i, _len;

      obj = dvl.urlHash.fromHashString(window.location.hash);
      for (_i = 0, _len = vars.length; _i < _len; _i++) {
        v = vars[_i];
        val = obj[v.name];
        if (validate(val)) {
          v.object.value(val);
        }
      }
    };
    worker = null;
    addHoock = function(v) {
      if (worker) {
        worker.addListen(v);
      } else {
        worker = dvl.register({
          name: 'hash_man',
          listen: [v],
          fn: inputChange,
          force: true
        });
        window.onhashchange = onHashChange;
      }
    };
    dvl.urlHash = function(_arg) {
      var key, object, updateHash, validate;

      key = _arg.key, object = _arg.object, validate = _arg.validate;
      vars.push({
        key: key,
        object: object,
        validate: validate
      });
      addHoock(object);
      return;
      updateHash = function() {
        var h;

        h = obj.value();
        if (window.location.hash !== h) {
          return window.location.hash = h;
        }
      };
      dvl.register({
        fn: updateHash,
        listen: [obj],
        name: 'hash_changer'
      });
    };
    dvl.urlHash.version = 3;
    dvl.urlHash.upgradeVersion = function() {
      throw "upgrade not defined";
    };
    dvl.urlHash.toHashString = function(obj) {
      return JSON.stringify(obj);
    };
    dvl.urlHash.fromHashString = function(str) {
      return JSON.parse(str);
    };
  })();

  dvl.chain = function(f, h) {
    var out;

    f = dvl.wrap(f);
    h = dvl.wrap(h);
    out = dvl().name('chain');
    dvl.register({
      listen: [f, h],
      change: [out],
      fn: function() {
        var _f, _h;

        _f = f.value();
        _h = h.value();
        if (_f && _h) {
          out.value(function(x) {
            return _h(_f(x));
          });
        } else {
          out.value(null);
        }
      }
    });
    return out;
  };

  (function() {
    var dvl_op, dvl_value, fn, k, op_to_lift;

    dvl_value = function(v) {
      return v.value();
    };
    dvl.op = dvl_op = function(fn) {
      var liftedFn;

      liftedFn = lift(fn);
      return function() {
        var args, out;

        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        args = args.map(dvl.wrap);
        out = dvl();
        dvl.register({
          listen: args,
          change: [out],
          fn: function() {
            out.set(liftedFn.apply(null, args.map(dvl_value)));
            dvl.notify(out);
          }
        });
        return out;
      };
    };
    op_to_lift = {
      'or': function() {
        var arg, ret, _i, _len;

        ret = false;
        for (_i = 0, _len = arguments.length; _i < _len; _i++) {
          arg = arguments[_i];
          ret || (ret = arg);
        }
        return ret;
      },
      'and': function() {
        var arg, ret, _i, _len;

        ret = true;
        for (_i = 0, _len = arguments.length; _i < _len; _i++) {
          arg = arguments[_i];
          ret && (ret = arg);
        }
        return ret;
      },
      'add': function() {
        var arg, sum, _i, _len;

        sum = 0;
        for (_i = 0, _len = arguments.length; _i < _len; _i++) {
          arg = arguments[_i];
          if (arg != null) {
            sum += arg;
          } else {
            return null;
          }
        }
        return sum;
      },
      'sub': function() {
        var arg, mult, sum, _i, _len;

        sum = 0;
        mult = 1;
        for (_i = 0, _len = arguments.length; _i < _len; _i++) {
          arg = arguments[_i];
          if (arg != null) {
            sum += arg * mult;
            mult = -1;
          } else {
            return null;
          }
        }
        return sum;
      },
      'list': function() {
        var arg, args, _i, _len;

        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        for (_i = 0, _len = args.length; _i < _len; _i++) {
          arg = args[_i];
          if (arg == null) {
            return null;
          }
        }
        return args;
      },
      'concat': function() {
        var arg, args, _i, _len;

        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        for (_i = 0, _len = args.length; _i < _len; _i++) {
          arg = args[_i];
          if (arg == null) {
            return null;
          }
        }
        return args.join('');
      },
      'iff': function(cond, truthy, falsy) {
        if (cond) {
          return truthy;
        } else {
          return falsy;
        }
      },
      'iffEq': function(lhs, rhs, truthy, falsy) {
        if (lhs === rhs) {
          return truthy;
        } else {
          return falsy;
        }
      },
      'iffLt': function(lhs, rhs, truthy, falsy) {
        if (lhs < rhs) {
          return truthy;
        } else {
          return falsy;
        }
      },
      'makeTranslate': function(x, y) {
        if ((x != null) && (y != null)) {
          return "translate(" + x + "," + y + ")";
        } else {
          return null;
        }
      }
    };
    for (k in op_to_lift) {
      fn = op_to_lift[k];
      dvl_op[k] = dvl_op(fn);
    }
  })();

  (function() {
    var class_concat, def_data_fn, id_class_spliter;

    id_class_spliter = /(?=[#.:])/;
    def_data_fn = dvl["const"](function(d) {
      return [d];
    });
    class_concat = dvl.op(function(s, d) {
      return s + ' ' + (d || '');
    });
    dvl.bind = function(_arg) {
      var argsOn, attr, attrList, data, html, join, k, listen, nodeType, onList, out, parent, part, parts, property, propertyList, self, staticClass, staticId, style, styleList, text, transition, transitionExit, v, _i, _len;

      parent = _arg.parent, self = _arg.self, data = _arg.data, join = _arg.join, attr = _arg.attr, style = _arg.style, property = _arg.property, text = _arg.text, html = _arg.html, argsOn = _arg.on, transition = _arg.transition, transitionExit = _arg.transitionExit;
      if (!parent) {
        throw "'parent' not defined";
      }
      if (typeof self !== 'string') {
        throw "'self' not defined";
      }
      parts = self.split(id_class_spliter);
      nodeType = parts.shift();
      staticId = null;
      staticClass = [];
      for (_i = 0, _len = parts.length; _i < _len; _i++) {
        part = parts[_i];
        switch (part[0]) {
          case '#':
            staticId = part.substring(1);
            break;
          case '.':
            staticClass.push(part.substring(1));
            break;
          default:
            throw "not currently supported in 'self' (" + part + ")";
        }
      }
      staticClass = staticClass.join(' ');
      parent = dvl.wrap(parent);
      data = dvl.wrap(data || def_data_fn);
      join = dvl.wrap(join);
      text = text ? dvl.wrap(text) : null;
      html = html ? dvl.wrap(html) : null;
      transition = dvl.wrap(transition);
      transitionExit = dvl.wrap(transitionExit);
      listen = [parent, data, join, text, html, transition, transitionExit];
      attrList = {};
      for (k in attr) {
        v = attr[k];
        v = dvl.wrap(v);
        if (k === 'class' && staticClass) {
          v = class_concat(staticClass, v);
        }
        listen.push(v);
        attrList[k] = v;
      }
      if (staticClass && !attrList['class']) {
        attrList['class'] = dvl["const"](staticClass);
      }
      styleList = {};
      for (k in style) {
        v = style[k];
        v = dvl.wrap(v);
        listen.push(v);
        styleList[k] = v;
      }
      propertyList = {};
      for (k in property) {
        v = property[k];
        v = dvl.wrap(v);
        listen.push(v);
        propertyList[k] = v;
      }
      onList = {};
      for (k in argsOn) {
        v = argsOn[k];
        v = dvl.wrap(v);
        listen.push(v);
        onList[k] = v;
      }
      out = dvl().name('selection');
      dvl.register({
        listen: listen,
        change: [out],
        fn: function() {
          var a, add1, add2, addO, e, enter, ex, force, postTrans, preTrans, s, t, _data, _j, _join, _k, _l, _len1, _len2, _len3, _parent, _transition, _transitionExit;

          _parent = parent.value();
          if (!_parent) {
            return;
          }
          force = parent.hasChanged() || data.hasChanged() || join.hasChanged();
          _data = data.value();
          _join = join.value();
          if (_data) {
            _data = _data.valueOf();
            _transition = transition.value();
            _transitionExit = transitionExit.value();
            enter = [];
            preTrans = [];
            postTrans = [];
            add1 = function(fn, v) {
              if (v.hasChanged() || force) {
                preTrans.push({
                  fn: fn,
                  a1: v.getPrev()
                });
                postTrans.push({
                  fn: fn,
                  a1: v.value()
                });
              } else {
                enter.push({
                  fn: fn,
                  a1: v.value()
                });
              }
            };
            add2 = function(fn, k, v) {
              if (v.hasChanged() || force) {
                enter.push({
                  fn: fn,
                  a1: k,
                  a2: v.getPrev()
                });
                preTrans.push({
                  fn: fn,
                  a1: k,
                  a2: v.getPrev()
                });
                postTrans.push({
                  fn: fn,
                  a1: k,
                  a2: v.value()
                });
              } else {
                enter.push({
                  fn: fn,
                  a1: k,
                  a2: v.value()
                });
              }
            };
            addO = function(fn, k, v) {
              if (v.hasChanged() || force) {
                preTrans.push({
                  fn: fn,
                  a1: k,
                  a2: v.value()
                });
              } else {
                enter.push({
                  fn: fn,
                  a1: k,
                  a2: v.value()
                });
              }
            };
            if (text) {
              add1('text', text);
            }
            if (html) {
              add1('html', html);
            }
            for (k in attrList) {
              v = attrList[k];
              add2('attr', k, v);
            }
            for (k in styleList) {
              v = styleList[k];
              add2('style', k, v);
            }
            for (k in propertyList) {
              v = propertyList[k];
              add2('property', k, v);
            }
            for (k in onList) {
              v = onList[k];
              addO('on', k, v);
            }
            s = _parent.selectAll(self).data(_data, _join);
            e = s.enter().append(nodeType);
            for (_j = 0, _len1 = enter.length; _j < _len1; _j++) {
              a = enter[_j];
              e[a.fn](a.a1, a.a2);
            }
            for (_k = 0, _len2 = preTrans.length; _k < _len2; _k++) {
              a = preTrans[_k];
              s[a.fn](a.a1, a.a2);
            }
            if (_transition && (_transition.duration != null)) {
              t = s.transition();
              t.duration(_transition.duration || 1000);
              if (_transition.delay) {
                t.delay(_transition.delay);
              }
              if (_transition.ease) {
                t.ease(_transition.ease);
              }
            } else {
              t = s;
            }
            for (_l = 0, _len3 = postTrans.length; _l < _len3; _l++) {
              a = postTrans[_l];
              t[a.fn](a.a1, a.a2);
            }
            ex = s.exit().remove();
            if (!e.empty() || !ex.empty() || force) {
              out.set(s).notify();
            }
          } else {
            s = _parent.selectAll(self).remove();
            out.set(s).notify();
          }
        }
      });
      return out;
    };
    return dvl.bindSingle = function(_arg) {
      var argsOn, attr, attrList, data, datum, html, k, listen, nodeType, onList, parent, part, parts, property, propertyList, self, staticClass, staticId, style, styleList, text, transition, v, _i, _len;

      parent = _arg.parent, self = _arg.self, data = _arg.data, datum = _arg.datum, attr = _arg.attr, style = _arg.style, property = _arg.property, text = _arg.text, html = _arg.html, argsOn = _arg.on, transition = _arg.transition;
      if (data) {
        throw new Error("bindSingle does not accept a parameter 'data'. Did you mean 'datum'?");
      }
      if (typeof self === 'string') {
        if (!parent) {
          throw "'parent' not defined for string self";
        }
        parts = self.split(id_class_spliter);
        nodeType = parts.shift();
        staticId = null;
        staticClass = [];
        for (_i = 0, _len = parts.length; _i < _len; _i++) {
          part = parts[_i];
          switch (part[0]) {
            case '#':
              staticId = part.substring(1);
              break;
            case '.':
              staticClass.push(part.substring(1));
              break;
            default:
              throw "not currently supported in 'self' (" + part + ")";
          }
        }
        staticClass = staticClass.join(' ');
        self = dvl.valueOf(parent).append(nodeType);
        self.attr('id', staticId) === staticId;
        self.attr('class', staticClass) === staticClass;
      } else {
        staticClass = self.attr('class');
      }
      self = dvl.wrapVar(self);
      datum = dvl.wrap(datum);
      text = text ? dvl.wrap(text) : null;
      html = html ? dvl.wrap(html) : null;
      transition = dvl.wrap(transition);
      listen = [datum, text, html, transition];
      attrList = {};
      for (k in attr) {
        v = attr[k];
        v = dvl.wrap(v);
        if (k === 'class' && staticClass) {
          v = class_concat(staticClass, v);
        }
        listen.push(v);
        attrList[k] = v;
      }
      styleList = {};
      for (k in style) {
        v = style[k];
        v = dvl.wrap(v);
        listen.push(v);
        styleList[k] = v;
      }
      propertyList = {};
      for (k in property) {
        v = property[k];
        v = dvl.wrap(v);
        listen.push(v);
        propertyList[k] = v;
      }
      onList = {};
      for (k in argsOn) {
        v = argsOn[k];
        v = dvl.wrap(v);
        listen.push(v);
        onList[k] = v;
      }
      dvl.register({
        listen: listen,
        change: [self],
        fn: function() {
          var force, sel, _datum;

          sel = self.value();
          _datum = datum.value();
          force = datum.hasChanged();
          if (force) {
            sel.datum(_datum);
          }
          for (k in attrList) {
            v = attrList[k];
            if (v.hasChanged() || force) {
              sel.attr(k, v.value());
            }
          }
          for (k in styleList) {
            v = styleList[k];
            if (v.hasChanged() || force) {
              sel.style(k, v.value());
            }
          }
          for (k in propertyList) {
            v = propertyList[k];
            if (v.hasChanged() || force) {
              sel.property(k, v.value());
            }
          }
          for (k in onList) {
            v = onList[k];
            if (v.hasChanged() || force) {
              sel.on(k, v.value());
            }
          }
          if (text && (text.hasChanged() || force)) {
            sel.text(text.value());
          }
          if (html && (html.hasChanged() || force)) {
            sel.html(html.value());
          }
          if (force) {
            self.notify();
          }
        }
      });
      return self;
    };
  })();

  dvl.data = {};

  dvl.data.min = function(data, acc) {
    acc || (acc = dvl.identity);
    return dvl.apply({
      args: [data, acc],
      update: true,
      fn: function(data, acc) {
        return d3.min(data.valueOf(), acc);
      }
    });
  };

  dvl.data.max = function(data, acc) {
    acc || (acc = dvl.identity);
    return dvl.apply({
      args: [data, acc],
      update: true,
      fn: function(data, acc) {
        return d3.max(data.valueOf(), acc);
      }
    });
  };

  dvl.snap = function(_arg) {
    var acc, data, name, out, trim, updateSnap, value;

    data = _arg.data, acc = _arg.acc, value = _arg.value, trim = _arg.trim, name = _arg.name;
    if (!data) {
      throw 'No data given';
    }
    acc = dvl.wrap(acc || dvl.identity);
    value = dvl.wrap(value);
    trim = dvl.wrap(trim || false);
    name || (name = 'snaped_data');
    out = dvl(null).name(name);
    updateSnap = function() {
      var a, d, dist, ds, i, minDatum, minDist, minIdx, v, _i, _len;

      ds = data.value();
      a = acc.value();
      v = value.value();
      if (ds && a && v) {
        ds = ds.valueOf();
        if (trim.value() && ds.length !== 0 && (v < a(ds[0]) || a(ds[ds.length - 1]) < v)) {
          minIdx = -1;
        } else {
          minIdx = -1;
          minDist = Infinity;
          if (ds) {
            for (i = _i = 0, _len = ds.length; _i < _len; i = ++_i) {
              d = ds[i];
              dist = Math.abs(a(d) - v);
              if (dist < minDist) {
                minDist = dist;
                minIdx = i;
              }
            }
          }
        }
        minDatum = minIdx < 0 ? null : ds[minIdx];
        if (out.value() !== minDatum) {
          out.set(minDatum);
        }
      } else {
        out.set(null);
      }
      return dvl.notify(out);
    };
    dvl.register({
      fn: updateSnap,
      listen: [data, acc, value, trim],
      change: [out],
      name: name + '_maker'
    });
    return out;
  };

  dvl.misc = {};

  dvl.misc.mouse = function(element, out) {
    var height, recorder, width;

    element = dvl.wrap(element);
    width = dvl.wrap(width);
    height = dvl.wrap(height);
    out = dvl.wrapVar(out, 'mouse');
    recorder = function() {
      var mouse, _element;

      _element = element.value();
      mouse = _element && d3.event ? d3.svg.mouse(_element.node()) : null;
      out.value(mouse);
    };
    element.value().on('mousemove', recorder).on('mouseout', recorder);
    dvl.register({
      name: 'mouse_recorder',
      listen: element,
      change: out,
      fn: recorder
    });
    return out;
  };

  dvl.misc.delay = function(data, time) {
    var out, timeoutFn, timer;

    if (time == null) {
      time = 1;
    }
    data = dvl.wrap(data);
    time = dvl.wrap(time);
    timer = null;
    out = dvl();
    timeoutFn = function() {
      out.value(data.value());
      timer = null;
    };
    dvl.register({
      listen: [data, time],
      change: [out],
      name: 'timeout',
      fn: function() {
        var t;

        if (timer) {
          clearTimeout(timer);
        }
        timer = null;
        if (time.value() != null) {
          t = Math.max(0, time.value());
          timer = setTimeout(timeoutFn, t);
        }
      }
    });
    return out;
  };

  clipId = 0;

  dvl.svg || (dvl.svg = {});

  dvl.svg.clipPath = function(_arg) {
    var cp, height, myId, parent, width, x, y;

    parent = _arg.parent, x = _arg.x, y = _arg.y, width = _arg.width, height = _arg.height;
    x = dvl.wrap(x || 0);
    y = dvl.wrap(y || 0);
    clipId++;
    myId = "cp" + clipId;
    cp = dvl.valueOf(parent).append('defs').append('clipPath').attr('id', myId);
    dvl.bind({
      parent: cp,
      self: 'rect',
      attr: {
        x: x,
        y: y,
        width: width,
        height: height
      }
    });
    return "url(#" + myId + ")";
  };

  dvl.html = {};

  dvl.html.resizer = function(_arg) {
    var dimension, fn, onResize, out, selector;

    selector = _arg.selector, out = _arg.out, dimension = _arg.dimension, fn = _arg.fn;
    out = dvl.wrapVar(out);
    dimension = dvl.wrap(dimension || 'width');
    fn = dvl.wrap(fn || dvl.identity);
    onResize = function() {
      var e, val, _dimension, _fn;

      _dimension = dimension.value();
      _fn = fn.value();
      if ((_dimension === 'width' || _dimension === 'height') && _fn) {
        if (selector) {
          e = jQuery(selector);
          val = e[_dimension]();
        } else {
          val = document.body[_dimension === 'width' ? 'clientWidth' : 'clientHeight'];
        }
        return out.value(_fn(val));
      } else {
        return out.value(null);
      }
    };
    $(window).resize(onResize);
    dvl.register({
      name: 'resizer',
      listen: [dimension, fn],
      change: [out],
      fn: onResize
    });
    return out;
  };

  dvl.html.out = function(_arg) {
    var attr, data, fn, format, hideInvalid, invalid, out, selector, style, text, updateHtml, what;

    selector = _arg.selector, data = _arg.data, fn = _arg.fn, format = _arg.format, invalid = _arg.invalid, hideInvalid = _arg.hideInvalid, attr = _arg.attr, style = _arg.style, text = _arg.text;
    if (!data) {
      throw 'must have data';
    }
    data = dvl.wrap(data);
    format = format != null ? format : fn;
    if (!selector) {
      throw 'must have selector';
    }
    selector = dvl.wrap(selector);
    format = dvl.wrap(format || dvl.identity);
    invalid = dvl.wrap(invalid || null);
    hideInvalid = dvl.wrap(hideInvalid || false);
    if (attr) {
      what = dvl.wrap(attr);
      out = function(selector, string) {
        return d3.select(selector).attr(what.value(), string);
      };
    } else if (style) {
      what = dvl.wrap(style);
      out = function(selector, string) {
        return d3.select(selector).style(what.value(), string);
      };
    } else if (text) {
      out = function(selector, string) {
        return d3.select(selector).text(string);
      };
    } else {
      out = function(selector, string) {
        return d3.select(selector).html(string);
      };
    }
    updateHtml = function() {
      var a, d, inv, s, sel;

      s = selector.value();
      a = format.value();
      d = data.value();
      if (s != null) {
        if ((a != null) && (d != null)) {
          sel = out(s, a(d));
          if (hideInvalid.value()) {
            sel.style('display', null);
          }
        } else {
          inv = invalid.value();
          out(s, inv);
          if (hideInvalid.value()) {
            d3.select(s).style('display', 'none');
          }
        }
      }
    };
    dvl.register({
      fn: updateHtml,
      listen: [data, selector, format],
      name: 'html_out'
    });
  };

  dvl.html.list = function(_arg) {
    var classStr, data, extras, highlight, i, icons, label, link, listClass, myOnEnter, myOnLeave, onClick, onEnter, onLeave, onSelect, parent, selection, selections, ul, _i, _len;

    parent = _arg.parent, data = _arg.data, label = _arg.label, link = _arg.link, listClass = _arg["class"], selection = _arg.selection, selections = _arg.selections, onSelect = _arg.onSelect, onEnter = _arg.onEnter, onLeave = _arg.onLeave, icons = _arg.icons, extras = _arg.extras, classStr = _arg.classStr, highlight = _arg.highlight;
    if (!parent) {
      throw 'must have parent';
    }
    if (!data) {
      throw 'must have data';
    }
    selection = dvl.wrapVar(selection, 'selection');
    selections = dvl.wrapVar(selections || [], 'selections');
    highlight = dvl.wrapVar(highlight, 'highlight');
    data = dvl.wrap(data);
    label = dvl.wrap(label || dvl.identity);
    link = dvl.wrap(link);
    icons || (icons = []);
    for (_i = 0, _len = icons.length; _i < _len; _i++) {
      i = icons[_i];
      i.position || (i.position = 'right');
    }
    if (listClass != null) {
      listClass = dvl.wrap(listClass);
    } else {
      listClass = dvl.applyAlways([selection, selections, highlight], function(_selection, _selections, _highlight) {
        return function(d) {
          var classParts;

          classParts = [];
          if (_selection) {
            classParts.push(d === _selection ? 'is_selection' : 'isnt_selection');
          }
          if (_selections) {
            classParts.push(__indexOf.call(_selections, d) >= 0 ? 'is_selections' : 'isnt_selections');
          }
          if (_highlight) {
            classParts.push(d === _highlight ? 'is_highlight' : 'isnt_highlight');
          }
          if (classParts.length) {
            return classParts.join(' ');
          } else {
            return null;
          }
        };
      });
    }
    ul = dvl.valueOf(parent).append('ul').attr('class', classStr);
    onClick = dvl.group(function(val, i) {
      var linkVal, _base, _selections;

      if ((typeof onSelect === "function" ? onSelect(val, i) : void 0) === false) {
        return;
      }
      linkVal = typeof (_base = link.value()) === "function" ? _base(val) : void 0;
      selection.value(val);
      _selections = (selections.value() || []).slice();
      i = _selections.indexOf(val);
      if (i === -1) {
        _selections.push(val);
      } else {
        _selections.splice(i, 1);
      }
      selections.value(_selections);
      if (linkVal) {
        window.location.href = linkVal;
      }
    });
    myOnEnter = function(val) {
      if ((typeof onEnter === "function" ? onEnter(val) : void 0) === false) {
        return;
      }
      highlight.value(val);
    };
    myOnLeave = function(val) {
      if ((typeof onLeave === "function" ? onLeave(val) : void 0) === false) {
        return;
      }
      if (highlight.value() === val) {
        highlight.value("");
      }
    };
    dvl.register({
      name: 'update_html_list',
      listen: [data, label, link],
      fn: function() {
        var a, addIcons, cont, sel, _class, _data, _label, _link;

        _data = data.value();
        _label = label.value();
        _link = link.value();
        _class = listClass.value();
        if (!_data) {
          return;
        }
        _data = _data.valueOf();
        addIcons = function(el, position) {
          icons.forEach(function(icon) {
            if (icon.position !== position) {
              return;
            }
            classStr = 'icon_cont ' + position;
            if (icon.classStr) {
              classStr += ' ' + icon.classStr;
            }
            el.append('div').attr('class', classStr).attr('title', icon.title).on('click', function(val, i) {
              if ((typeof icon.onSelect === "function" ? icon.onSelect(val, i) : void 0) === false) {
                d3.event.stopPropagation();
              }
            }).on('mouseover', function(val, i) {
              if ((typeof icon.onEnter === "function" ? icon.onEnter(val, i) : void 0) === false) {
                d3.event.stopPropagation();
              }
            }).on('mouseout', function(val, i) {
              if ((typeof icon.onLeave === "function" ? icon.onLeave(val, i) : void 0) === false) {
                d3.event.stopPropagation();
              }
            }).append('div').attr('class', 'icon');
          });
        };
        sel = ul.selectAll('li').data(_data);
        a = sel.enter().append('li').append('a');
        addIcons(a, 'left');
        a.append('span');
        addIcons(a, 'right');
        cont = sel.attr('class', _class).on('click', onClick).on('mouseover', myOnEnter).on('mouseout', myOnLeave).select('a').attr('href', _link);
        cont.select('span').text(_label);
        sel.exit().remove();
      }
    });
    dvl.register({
      name: 'update_class_list',
      listen: [listClass],
      fn: function() {
        var _class;

        _class = listClass.value();
        ul.selectAll('li').attr('class', _class);
      }
    });
    return {
      selection: selection,
      selections: selections,
      node: ul.node()
    };
  };

  dvl.html.combobox = function(_arg) {
    var classStr, data, disabled, divCont, filterCharacters, filteredData, focus, highlight, icons, id, keepOnClick, label, link, listClass, menuAnchor, menuCont, menuOpen, myOnSelect, namespace, onEnter, onLeave, onSelect, parent, selection, selectionLabel, selections, title, updateScroll, valueOut;

    parent = _arg.parent, classStr = _arg.classStr, data = _arg.data, label = _arg.label, selectionLabel = _arg.selectionLabel, link = _arg.link, listClass = _arg["class"], id = _arg.id, selection = _arg.selection, selections = _arg.selections, onSelect = _arg.onSelect, onEnter = _arg.onEnter, onLeave = _arg.onLeave, menuAnchor = _arg.menuAnchor, title = _arg.title, icons = _arg.icons, keepOnClick = _arg.keepOnClick, disabled = _arg.disabled, highlight = _arg.highlight, focus = _arg.focus;
    if (!parent) {
      throw 'must have parent';
    }
    if (!data) {
      throw 'must have data';
    }
    selection = dvl.wrapVar(selection, 'selection');
    selections = dvl.wrapVar(selections, 'selections');
    menuAnchor = dvl.wrap(menuAnchor || 'left');
    data = dvl.wrap(data);
    label = dvl.wrap(label || dvl.identity);
    selectionLabel = dvl.wrap(selectionLabel || label);
    link = dvl.wrap(link);
    disabled = dvl.wrap(disabled != null ? disabled : false);
    focus = dvl.wrapVar(focus);
    filterCharacters = dvl.wrapVar([]).compare(false);
    filteredData = dvl.def();
    dvl.register({
      listen: data,
      fn: function() {
        var _data, _selection;

        _data = data.value();
        _selection = selection.value();
        if (!_data || __indexOf.call(_data, _selection) < 0) {
          setTimeout((function() {
            return selection.value(null);
          }), 0);
        }
      }
    });
    dvl.register({
      listen: filterCharacters,
      label: label,
      data: data,
      change: filteredData,
      fn: function() {
        var _data, _filterCharacters, _filterPhrase, _filteredData, _label;

        _data = data.value();
        _filterCharacters = filterCharacters.value();
        _label = label.value();
        if (!(_data && _filterCharacters)) {
          return;
        }
        _filterPhrase = _filterCharacters.join('');
        _filteredData = _data.filter(function(datum) {
          var _ref;

          return ((_ref = String(_label(datum))) != null ? _ref.toLowerCase().indexOf(_filterPhrase) : void 0) > -1;
        });
        return filteredData.value(_filteredData);
      }
    });
    if (title) {
      title = dvl.wrap(title);
    }
    icons || (icons = []);
    menuOpen = dvl(false);
    dvl.register({
      listen: menuOpen,
      change: filterCharacters,
      fn: function() {
        return filterCharacters.value([]);
      }
    });
    divCont = dvl.bindSingle({
      parent: parent,
      self: 'div',
      attr: {
        "class": dvl.applyAlways({
          args: [classStr, menuOpen, disabled],
          fn: function(_classStr, _menuOpen, _disabled) {
            return [_classStr || '', _menuOpen ? 'open' : 'closed', _disabled ? 'disabled' : ''].join(' ');
          }
        })
      },
      style: {
        position: 'relative'
      }
    }).value();
    valueOut = dvl.bindSingle({
      parent: divCont,
      self: 'input.title-cont',
      attr: {
        disabled: dvl.op.iff(disabled, '', null),
        tabIndex: 0,
        id: id
      },
      on: {
        blur: function() {
          focus.value(false);
        }
      }
    }).value();
    updateScroll = function() {
      var element, selectionIndex, _data, _menuCont, _selection;

      _data = data.value();
      _selection = selection.value();
      if (!_data) {
        return;
      }
      selectionIndex = _data.indexOf(_selection);
      if (selectionIndex === -1) {
        return;
      }
      _menuCont = menuCont.node();
      if (_menuCont.scrollHeight === 0) {
        return;
      }
      element = menuCont.selectAll('li')[0][selectionIndex];
      _menuCont.scrollTop = 0;
      _menuCont.scrollTop = $(element).position().top;
    };
    valueOut.on('keydown', (function() {
      var keyCode, selectionIndex, _data, _filterCharacters, _label, _selection;

      _data = data.value();
      if (!_data) {
        return;
      }
      _label = label.value();
      if (!_label) {
        return;
      }
      keyCode = d3.event.which || d3.event.keyCode;
      if (keyCode === 9) {
        menuOpen.value(false);
        return;
      }
      if (keyCode === 38 || keyCode === 40) {
        d3.event.stopPropagation();
        d3.event.preventDefault();
        if (!menuOpen.value()) {
          menuOpen.value(true);
        }
        _selection = selection.value();
        selectionIndex = _data.indexOf(_selection);
        if (selectionIndex === -1) {
          if (_selection === null) {
            if (_data.length) {
              selection.value(_data[0]);
            }
          } else {
            throw "selection was not found in data";
          }
        } else {
          if (keyCode === 38) {
            selectionIndex--;
          } else {
            selectionIndex++;
          }
          selectionIndex += _data.length;
          selectionIndex %= _data.length;
          selection.value(_data[selectionIndex]);
          updateScroll();
        }
      }
      if (keyCode === 13 || keyCode === 27) {
        d3.event.stopPropagation();
        d3.event.preventDefault();
        menuOpen.value(false);
      }
      if (keyCode === 8) {
        _filterCharacters = filterCharacters.value();
        _filterCharacters.pop();
        filterCharacters.value(_filterCharacters);
      }
    }), true).on('keypress', (function() {
      var keyCode, _data, _filterCharacters, _label;

      _data = data.value();
      if (!_data) {
        return;
      }
      _label = label.value();
      if (!_label) {
        return;
      }
      keyCode = d3.event.which || d3.event.keyCode;
      if (!(keyCode === 9 || keyCode === 38 || keyCode === 40 || keyCode === 13 || keyCode === 27)) {
        _filterCharacters = filterCharacters.value();
        _filterCharacters.push(String.fromCharCode(keyCode).toLowerCase());
        filterCharacters.value(_filterCharacters);
      }
    }), true);
    dvl.register({
      listen: [focus],
      fn: function() {
        var _focus, _valueOut;

        _focus = focus.value();
        if (_focus == null) {
          return;
        }
        _valueOut = valueOut.node();
        if (_focus === (_valueOut === document.activeElement)) {
          return;
        }
        setTimeout((function() {
          if (_focus) {
            _valueOut.focus();
          } else {
            _valueOut.blur();
          }
        }), 0);
      }
    });
    myOnSelect = function(text, i) {
      if (!keepOnClick) {
        menuOpen.value(false);
      }
      return typeof onSelect === "function" ? onSelect(text, i) : void 0;
    };
    icons.forEach(function(icon) {
      var icon_onSelect;

      icon_onSelect = icon.onSelect;
      icon.onSelect = function(val, i) {
        if (!keepOnClick) {
          menuOpen.value(false);
        }
        return typeof icon_onSelect === "function" ? icon_onSelect(val, i) : void 0;
      };
    });
    menuCont = divCont.append('div').attr('class', 'menu-cont').style('position', 'absolute').style('z-index', 1000);
    dvl.register({
      listen: [menuOpen, menuAnchor],
      fn: function() {
        var _menuAnchor, _menuOpen;

        _menuOpen = menuOpen.value();
        if (_menuOpen) {
          menuCont.style('display', null).style('top', '100%');
          _menuAnchor = menuAnchor.value();
          if (_menuAnchor === 'left') {
            menuCont.style('left', 0).style('right', null);
          } else {
            menuCont.style('left', null).style('right', 0);
          }
        } else {
          menuCont.style('display', 'none');
        }
      }
    });
    dvl.html.list({
      parent: menuCont,
      classStr: 'list',
      data: filteredData,
      label: label,
      link: link,
      "class": listClass,
      selection: selection,
      selections: selections,
      onSelect: myOnSelect,
      onEnter: onEnter,
      onLeave: onLeave,
      icons: icons
    });
    namespace = dvl.namespace('dropdown');
    d3.select(window).on("click." + namespace, (function() {
      var target;

      target = d3.event.target;
      if (disabled.value()) {
        return;
      }
      if ($(menuCont.node()).find(target).length) {
        return;
      }
      if (divCont.node() === target || $(divCont.node()).find(target).length) {
        menuOpen.value(!menuOpen.value());
      } else {
        menuOpen.value(false);
      }
    }), true).on("blur." + namespace, function() {
      menuOpen.value(false);
    });
    dvl.register({
      name: 'selection_updater',
      listen: [menuOpen, selection, selectionLabel, title],
      fn: function() {
        var sel, selLabel, titleText;

        if (menuOpen.value()) {
          valueOut.property('value', '');
          return;
        }
        if (title) {
          titleText = title.value();
        } else {
          sel = selection.value();
          selLabel = selectionLabel.value();
          titleText = selLabel ? selLabel(sel) : '';
        }
        valueOut.property('value', titleText != null ? titleText : '');
      }
    });
    return {
      node: divCont.node(),
      menuCont: menuCont.node(),
      open: menuOpen,
      focus: focus,
      selection: selection,
      selections: selections
    };
  };

  dvl.html.dropdown = function(_arg) {
    var classStr, data, disabled, divCont, focus, highlight, icons, id, keepOnClick, label, link, listClass, menuAnchor, menuCont, menuOpen, myOnSelect, namespace, onEnter, onLeave, onSelect, parent, selection, selectionLabel, selections, title, updateScroll, valueOut;

    parent = _arg.parent, classStr = _arg.classStr, data = _arg.data, label = _arg.label, selectionLabel = _arg.selectionLabel, link = _arg.link, listClass = _arg["class"], id = _arg.id, selection = _arg.selection, selections = _arg.selections, onSelect = _arg.onSelect, onEnter = _arg.onEnter, onLeave = _arg.onLeave, menuAnchor = _arg.menuAnchor, title = _arg.title, icons = _arg.icons, keepOnClick = _arg.keepOnClick, disabled = _arg.disabled, highlight = _arg.highlight, focus = _arg.focus;
    if (!parent) {
      throw 'must have parent';
    }
    if (!data) {
      throw 'must have data';
    }
    selection = dvl.wrapVar(selection, 'selection');
    selections = dvl.wrapVar(selections, 'selections');
    menuAnchor = dvl.wrap(menuAnchor || 'left');
    data = dvl.wrap(data);
    label = dvl.wrap(label || dvl.identity);
    selectionLabel = dvl.wrap(selectionLabel || label);
    link = dvl.wrap(link);
    disabled = dvl.wrap(disabled != null ? disabled : false);
    focus = dvl.wrapVar(focus);
    dvl.register({
      listen: data,
      fn: function() {
        var _data, _selection;

        _data = data.value();
        _selection = selection.value();
        if (!_data || __indexOf.call(_data, _selection) < 0) {
          setTimeout((function() {
            return selection.value(null);
          }), 0);
        }
      }
    });
    if (title) {
      title = dvl.wrap(title);
    }
    icons || (icons = []);
    menuOpen = dvl(false);
    divCont = dvl.bindSingle({
      parent: parent,
      self: 'div',
      attr: {
        "class": dvl.applyAlways({
          args: [classStr, menuOpen, disabled],
          fn: function(_classStr, _menuOpen, _disabled) {
            return [_classStr || '', _menuOpen ? 'open' : 'closed', _disabled ? 'disabled' : ''].join(' ');
          }
        })
      },
      style: {
        position: 'relative'
      }
    }).value();
    valueOut = dvl.bindSingle({
      parent: divCont,
      self: 'div.title-cont',
      attr: {
        disabled: dvl.op.iff(disabled, '', null),
        tabIndex: 0,
        id: id
      },
      on: {
        blur: function() {
          focus.value(false);
        }
      },
      text: title || dvl.applyAlways(selection, label)
    }).value();
    updateScroll = function() {
      var element, selectionIndex, _data, _menuCont, _selection;

      _data = data.value();
      _selection = selection.value();
      if (!_data) {
        return;
      }
      selectionIndex = _data.indexOf(_selection);
      if (selectionIndex === -1) {
        return;
      }
      _menuCont = menuCont.node();
      if (_menuCont.scrollHeight === 0) {
        return;
      }
      element = menuCont.selectAll('li')[0][selectionIndex];
      _menuCont.scrollTop = 0;
      _menuCont.scrollTop = $(element).position().top;
    };
    valueOut.on('keydown', (function() {
      var keyCode, selectionIndex, _data, _label, _selection;

      _data = data.value();
      if (!_data) {
        return;
      }
      _label = label.value();
      if (!_label) {
        return;
      }
      keyCode = d3.event.which || d3.event.keyCode;
      if (keyCode === 9) {
        menuOpen.value(false);
        return;
      }
      if (keyCode === 38 || keyCode === 40) {
        d3.event.stopPropagation();
        d3.event.preventDefault();
        if (!menuOpen.value()) {
          menuOpen.value(true);
        }
        _selection = selection.value();
        selectionIndex = _data.indexOf(_selection);
        if (selectionIndex === -1) {
          if (_selection === null) {
            if (_data.length) {
              selection.value(_data[0]);
            }
          } else {
            throw "selection was not found in data";
          }
        } else {
          if (keyCode === 38) {
            selectionIndex--;
          } else {
            selectionIndex++;
          }
          selectionIndex += _data.length;
          selectionIndex %= _data.length;
          selection.value(_data[selectionIndex]);
          updateScroll();
        }
      }
      if (keyCode === 13 || keyCode === 27) {
        d3.event.stopPropagation();
        d3.event.preventDefault();
        menuOpen.value(false);
      }
    }), true).on('keypress', (function() {
      var datum, keyCode, userChar, _data, _i, _label, _len;

      _data = data.value();
      if (!_data) {
        return;
      }
      _label = label.value();
      if (!_label) {
        return;
      }
      keyCode = d3.event.which || d3.event.keyCode;
      userChar = String.fromCharCode(keyCode).toLowerCase();
      if (userChar && !(keyCode === 9 || keyCode === 38 || keyCode === 40 || keyCode === 13 || keyCode === 27)) {
        for (_i = 0, _len = _data.length; _i < _len; _i++) {
          datum = _data[_i];
          if (datum && _label(datum).charAt(0).toLowerCase() === userChar) {
            selection.value(datum);
            updateScroll();
            break;
          }
        }
      }
    }), true);
    dvl.register({
      listen: [focus],
      fn: function() {
        var _focus, _valueOut;

        _focus = focus.value();
        if (_focus == null) {
          return;
        }
        _valueOut = valueOut.node();
        if (_focus === (_valueOut === document.activeElement)) {
          return;
        }
        setTimeout((function() {
          if (_focus) {
            _valueOut.focus();
          } else {
            _valueOut.blur();
          }
        }), 0);
      }
    });
    myOnSelect = function(text, i) {
      if (!keepOnClick) {
        menuOpen.value(false);
      }
      return typeof onSelect === "function" ? onSelect(text, i) : void 0;
    };
    icons.forEach(function(icon) {
      var icon_onSelect;

      icon_onSelect = icon.onSelect;
      icon.onSelect = function(val, i) {
        if (!keepOnClick) {
          menuOpen.value(false);
        }
        return typeof icon_onSelect === "function" ? icon_onSelect(val, i) : void 0;
      };
    });
    menuCont = divCont.append('div').attr('class', 'menu-cont').style('position', 'absolute').style('z-index', 1000);
    dvl.register({
      listen: [menuOpen, menuAnchor],
      fn: function() {
        var _menuAnchor, _menuOpen;

        _menuOpen = menuOpen.value();
        if (_menuOpen) {
          menuCont.style('display', null).style('top', '100%');
          _menuAnchor = menuAnchor.value();
          if (_menuAnchor === 'left') {
            menuCont.style('left', 0).style('right', null);
          } else {
            menuCont.style('left', null).style('right', 0);
          }
        } else {
          menuCont.style('display', 'none');
        }
      }
    });
    dvl.html.list({
      parent: menuCont,
      classStr: 'list',
      data: data,
      label: label,
      link: link,
      "class": listClass,
      selection: selection,
      selections: selections,
      onSelect: myOnSelect,
      onEnter: onEnter,
      onLeave: onLeave,
      icons: icons
    });
    namespace = dvl.namespace('dropdown');
    d3.select(window).on("click." + namespace, (function() {
      var target;

      target = d3.event.target;
      if (disabled.value()) {
        return;
      }
      if ($(menuCont.node()).find(target).length) {
        return;
      }
      if (divCont.node() === target || $(divCont.node()).find(target).length) {
        menuOpen.value(!menuOpen.value());
      } else {
        menuOpen.value(false);
      }
    }), true).on("blur." + namespace, function() {
      menuOpen.value(false);
    });
    dvl.register({
      name: 'selection_updater',
      listen: [selection, selectionLabel, title],
      fn: function() {
        var sel, selLabel, titleText;

        if (title) {
          titleText = title.value();
        } else {
          sel = selection.value();
          selLabel = selectionLabel.value();
          titleText = selLabel ? selLabel(sel) : '';
        }
        valueOut.property('value', titleText != null ? titleText : '');
      }
    });
    return {
      node: divCont.node(),
      menuCont: menuCont.node(),
      open: menuOpen,
      focus: focus,
      selection: selection,
      selections: selections
    };
  };

  dvl.html.select = function(_arg) {
    var classStr, data, focus, id, label, onChange, parent, selChange, selectEl, selection, visible;

    parent = _arg.parent, data = _arg.data, classStr = _arg.classStr, label = _arg.label, selection = _arg.selection, id = _arg.id, onChange = _arg.onChange, focus = _arg.focus, visible = _arg.visible;
    if (!parent) {
      throw 'must have parent';
    }
    if (!data) {
      throw 'must have data';
    }
    selection = dvl.wrapVar(selection, 'selection');
    focus = dvl.wrapVar(focus != null ? focus : false);
    visible = dvl.wrap(visible != null ? visible : true);
    data = dvl.wrap(data);
    label = dvl.wrap(label || dvl.identity);
    selChange = function() {
      var i, val, _data, _selectEl;

      _data = data.value();
      if (_data) {
        _data = _data.valueOf();
        _selectEl = selectEl.value();
        i = _selectEl.property('value');
        val = _data[i];
        if ((typeof onChange === "function" ? onChange(val) : void 0) === false) {
          return;
        }
        selection.value(val);
      } else {
        selection.value(null);
      }
    };
    selectEl = dvl.bindSingle({
      parent: parent,
      self: 'select',
      attr: {
        id: id,
        "class": classStr
      },
      style: {
        display: dvl.op.iff(visible, null, 'none')
      },
      on: {
        change: selChange,
        focus: function() {
          focus.value(true);
        },
        blur: function() {
          focus.value(false);
        }
      }
    });
    dvl.bind({
      parent: selectEl,
      self: 'option',
      data: data,
      attr: {
        value: function(d, i) {
          return i;
        }
      },
      text: label
    });
    dvl.register({
      listen: [data, selection],
      fn: function() {
        var idx, _data, _selectEl, _selection;

        _data = data.value();
        _selection = selection.value();
        if (!_data) {
          return;
        }
        _data = _data.valueOf();
        idx = _data.indexOf(_selection);
        _selectEl = selectEl.value();
        if (_selectEl.property('value') !== idx) {
          _selectEl.property('value', idx);
        }
      }
    });
    dvl.register({
      listen: [selectEl, focus],
      fn: function() {
        var _focus, _selectEl;

        _selectEl = selectEl.value();
        _focus = focus.value();
        if (!(_selectEl && (_focus != null))) {
          return;
        }
        _selectEl = _selectEl.node();
        return _focus === (_selectEl === document.activeElement);
        if (_focus) {
          _selectEl.focus();
        } else {
          _selectEl.blur();
        }
      }
    });
    selChange();
    return {
      node: selectEl.value(),
      selection: selection,
      focus: focus
    };
  };

  dvl.compare = function(acc, reverse) {
    acc = dvl.wrap(acc || dvl.identity);
    reverse = dvl.wrap(reverse || false);
    return dvl.apply({
      args: [acc, reverse],
      fn: function(acc, reverse) {
        var cmp;

        cmp = reverse ? d3.descending : d3.ascending;
        return function(a, b) {
          return cmp(acc(a), acc(b));
        };
      }
    });
  };

  (function() {
    var addPxIfNeeded, defaultCompareModes, numberRegEx;

    defaultCompareModes = ['up', 'down'];
    numberRegEx = /\d+(?:\.\d+)?/;
    addPxIfNeeded = function(str) {
      if (str == null) {
        return null;
      }
      if (numberRegEx.test(str)) {
        return str + 'px';
      } else {
        return str;
      }
    };
    dvl.html.table = function(_arg) {
      var bodyCol, c, classStr, columns, comp, compare, compareList, compareMap, data, headParent, headTable, headerCol, onRow, parent, rowClass, rowLimit, sort, sortDir, sortOn, sortOnIndicator, table, _i, _len, _ref;

      parent = _arg.parent, headParent = _arg.headParent, data = _arg.data, sort = _arg.sort, classStr = _arg.classStr, rowClass = _arg.rowClass, rowLimit = _arg.rowLimit, columns = _arg.columns, onRow = _arg.on;
      table = dvl.bindSingle({
        parent: parent,
        self: 'table',
        attr: {
          "class": classStr
        }
      });
      if (headParent) {
        headTable = dvl.bindSingle({
          parent: headParent,
          self: 'table',
          attr: {
            "class": (classStr != null ? classStr : '') + ' head'
          }
        });
      } else {
        headTable = table;
      }
      sort || (sort = {});
      sortOn = dvl.wrapVar(sort.on);
      sortDir = dvl.wrapVar(sort.dir);
      sortOnIndicator = dvl.wrapVar((_ref = sort.onIndicator) != null ? _ref : sortOn);
      headerCol = [];
      bodyCol = [];
      compareMap = {};
      compareList = [sortOn, sortDir];
      for (_i = 0, _len = columns.length; _i < _len; _i++) {
        c = columns[_i];
        if (c.sortable) {
          if (c.compare != null) {
            comp = dvl.wrap(c.compare);
          } else {
            if (c.ignoreCase) {
              comp = dvl.compare(dvl.chain(c.value, function(d) {
                if (d) {
                  return d.toLowerCase();
                } else {
                  return d;
                }
              }));
            } else {
              comp = dvl.compare(c.value);
            }
          }
          compareMap[c.id] = comp;
          compareList.push(comp);
          if (!c.compareModes) {
            c.compareModes = defaultCompareModes;
          }
        }
        headerCol.push({
          id: c.id,
          title: c.title,
          "class": (c["class"] || '') + (c.sortable ? ' sortable' : ''),
          visible: c.visible,
          tooltip: c.headerTooltip,
          width: c.width
        });
        bodyCol.push({
          id: c.id,
          "class": c["class"],
          visible: c.visible,
          value: c.value,
          hover: c.hover,
          render: c.render,
          on: c.on,
          width: c.width
        });
      }
      headerCol.forEach(function(c) {
        c.indicator = dvl.applyAlways([sortOn, sortDir], function(_sortOn, _sortDir) {
          if (_sortOn === c.id) {
            return _sortDir || 'none';
          } else {
            return 'none';
          }
        });
      });
      compare = dvl(null);
      dvl.register({
        listen: compareList,
        change: [compare],
        fn: function() {
          var cmp, oldCmp, _ref1, _sortDir, _sortOn;

          _sortOn = sortOn.value();
          _sortDir = sortDir.value();
          if (_sortOn != null) {
            cmp = (_ref1 = compareMap[_sortOn]) != null ? _ref1.value() : void 0;
            if (cmp && _sortDir === 'down') {
              oldCmp = cmp;
              cmp = function(a, b) {
                return oldCmp(b, a);
              };
            }
            compare.value(cmp);
          } else {
            compare.value(null);
          }
        }
      });
      dvl.html.table.header({
        parent: headTable,
        columns: headerCol,
        onClick: function(id) {
          var column, compareModes, _j, _len1;

          column = null;
          for (_j = 0, _len1 = columns.length; _j < _len1; _j++) {
            c = columns[_j];
            if (c.id === id) {
              column = c;
              break;
            }
          }
          if (!(column && column.sortable)) {
            return;
          }
          compareModes = column.compareModes;
          if (id === sortOn.value()) {
            sortDir.set(compareModes[(compareModes.indexOf(sortDir.value()) + 1) % compareModes.length]);
            dvl.notify(sortDir);
          } else {
            sortOn.set(id);
            sortDir.set(compareModes[0]);
            dvl.notify(sortOn, sortDir);
          }
        }
      });
      dvl.html.table.body({
        parent: table,
        classStr: 'data',
        data: data,
        rowClass: rowClass,
        rowLimit: rowLimit,
        columns: bodyCol,
        compare: compare,
        on: onRow
      });
      return {
        node: table
      };
    };
    dvl.html.table.header = function(_arg) {
      var c, columns, enterLiner, enterTh, headerRow, listen, nc, newColumns, onClick, parent, sel, thead, _i, _len, _ref;

      parent = _arg.parent, columns = _arg.columns, onClick = _arg.onClick;
      if (!parent) {
        throw 'there needs to be a parent';
      }
      onClick = dvl.wrap(onClick);
      thead = dvl.valueOf(parent).append('thead');
      headerRow = thead.append('tr');
      listen = [onClick];
      newColumns = [];
      for (_i = 0, _len = columns.length; _i < _len; _i++) {
        c = columns[_i];
        newColumns.push(nc = {
          id: c.id,
          title: dvl.wrap(c.title),
          "class": dvl.wrap(c["class"]),
          visible: dvl.wrap((_ref = c.visible) != null ? _ref : true),
          tooltip: dvl.wrap(c.tooltip),
          indicator: c.indicator ? dvl.wrap(c.indicator) : void 0,
          width: dvl.wrap(c.width)
        });
        listen.push(nc.title, nc["class"], nc.visible, nc.tooltip, nc.indicator, nc.width);
      }
      columns = newColumns;
      sel = headerRow.selectAll('th').data(columns);
      enterTh = sel.enter().append('th');
      enterLiner = enterTh.append('div').attr('class', 'liner');
      enterLiner.append('span');
      enterLiner.append('div').attr('class', 'indicator').style('display', 'none');
      sel.exit().remove();
      dvl.register({
        name: 'header_render',
        listen: listen,
        fn: function() {
          var i, ind, visibleChanged, w, _indicator, _j, _len1;

          for (i = _j = 0, _len1 = columns.length; _j < _len1; i = ++_j) {
            c = columns[i];
            sel = headerRow.select("th:nth-child(" + (i + 1) + ")");
            visibleChanged = c.visible.hasChanged();
            if (c.visible.value()) {
              sel.datum(c);
              if (c["class"].hasChanged() || visibleChanged) {
                sel.attr('class', c["class"].value());
              }
              if (c.tooltip.hasChanged() || visibleChanged) {
                sel.attr('title', c.tooltip.value());
              }
              if (c.width.hasChanged() || visibleChanged) {
                w = addPxIfNeeded(c.width.value());
                sel.style('min-width', w).style('width', w).style('max-width', w);
              }
              if (visibleChanged) {
                sel.style('display', null);
              }
              if (onClick.hasChanged() || visibleChanged) {
                sel.on('click', function(d) {
                  var _base;

                  return typeof (_base = onClick.value()) === "function" ? _base(d.id) : void 0;
                });
              }
              if (c.title.hasChanged() || visibleChanged) {
                sel.select('span').text(c.title.value());
              }
              if (c.indicator && (c.indicator.hasChanged() || visibleChanged)) {
                _indicator = c.indicator.value();
                ind = sel.select('div.indicator');
                if (_indicator) {
                  ind.style('display', null).attr('class', 'indicator ' + _indicator);
                } else {
                  ind.style('display', 'none');
                }
              }
            } else {
              if (visibleChanged) {
                sel.style('display', 'none');
              }
            }
          }
        }
      });
      return {
        node: thead
      };
    };
    dvl.html.table.body = function(_arg) {
      var c, change, classStr, columns, compare, data, k, listen, nc, newColumns, onRow, onRowNew, parent, render, rowClass, rowLimit, tbody, v, _i, _j, _len, _len1, _ref, _ref1;

      parent = _arg.parent, data = _arg.data, compare = _arg.compare, rowClass = _arg.rowClass, classStr = _arg.classStr, rowLimit = _arg.rowLimit, columns = _arg.columns, onRow = _arg.on;
      if (!parent) {
        throw 'there needs to be a parent';
      }
      if (!data) {
        throw 'there needs to be data';
      }
      tbody = dvl.valueOf(parent).append('tbody').attr('class', classStr);
      compare = dvl.wrap(compare);
      if (rowClass != null) {
        rowClass = dvl.wrap(rowClass);
      }
      rowLimit = dvl.wrap(rowLimit);
      listen = [data, compare, rowClass, rowLimit];
      change = [];
      onRowNew = {};
      for (k in onRow) {
        v = onRow[k];
        v = dvl.wrap(v);
        listen.push(v);
        onRowNew[k] = v;
      }
      onRow = onRowNew;
      newColumns = [];
      for (_i = 0, _len = columns.length; _i < _len; _i++) {
        c = columns[_i];
        newColumns.push(nc = {
          id: c.id,
          "class": dvl.wrap(c["class"]),
          visible: dvl.wrap((_ref = c.visible) != null ? _ref : true),
          hover: dvl.wrap(c.hover),
          value: dvl.wrap(c.value),
          width: dvl.wrap(c.width)
        });
        listen.push(nc["class"], nc.visible, nc.hover, nc.width);
        nc.render = c.render || 'text';
        nc.on = {};
        _ref1 = c.on;
        for (k in _ref1) {
          v = _ref1[k];
          v = dvl.wrap(v);
          listen.push(v);
          nc.on[k] = v;
        }
        change.push(nc.selection = dvl().name("" + c.id + "_selection"));
      }
      columns = newColumns;
      dvl.register({
        name: 'body_render',
        listen: listen,
        change: change,
        fn: function() {
          var colSel, dataSorted, enterRowSel, i, rowSel, sel, visibleChanged, w, _compare, _j, _len1, _ref2, _rowClass, _rowLimit;

          dataSorted = (data.value() || []).valueOf();
          _compare = compare.value();
          if (_compare) {
            dataSorted = dataSorted.slice().sort(_compare);
          }
          _rowLimit = rowLimit.value();
          if (_rowLimit != null) {
            dataSorted = dataSorted.slice(0, _rowLimit);
          }
          rowSel = tbody.selectAll('tr').data(dataSorted);
          enterRowSel = rowSel.enter().append('tr');
          rowSel.exit().remove();
          if (rowClass) {
            _rowClass = rowClass.value();
            rowSel.attr('class', _rowClass);
          }
          for (k in onRow) {
            v = onRow[k];
            rowSel.on(k, v.value());
          }
          colSel = rowSel.selectAll('td').data(columns);
          colSel.enter().append('td');
          colSel.exit().remove();
          for (i = _j = 0, _len1 = columns.length; _j < _len1; i = ++_j) {
            c = columns[i];
            sel = tbody.selectAll("td:nth-child(" + (i + 1) + ")").data(dataSorted);
            visibleChanged = c.visible.hasChanged() || data.hasChanged();
            if (c.visible.value()) {
              if (c["class"].hasChanged() || visibleChanged) {
                sel.attr('class', c["class"].value());
              }
              if (c.hover.hasChanged() || visibleChanged) {
                sel.attr('title', c.hover.value());
              }
              if (c.width.hasChanged() || visibleChanged) {
                w = addPxIfNeeded(c.width.value());
                sel.style('min-width', w).style('width', w).style('max-width', w);
              }
              if (visibleChanged) {
                sel.style('display', null);
              }
              _ref2 = c.on;
              for (k in _ref2) {
                v = _ref2[k];
                if (v.hasChanged() || visibleChanged) {
                  sel.on(k, v.value());
                }
              }
              c.selection.set(sel).notify();
            } else {
              if (visibleChanged) {
                sel.style('display', 'none');
              }
            }
          }
        }
      });
      for (_j = 0, _len1 = columns.length; _j < _len1; _j++) {
        c = columns[_j];
        render = typeof c.render === 'function' ? c.render : dvl.html.table.render[c.render];
        render.call(c, c.selection, c.value);
      }
      return {
        node: tbody
      };
    };
    return dvl.html.table.render = {
      text: function(selection, value) {
        dvl.register({
          listen: [selection, value],
          fn: function() {
            var _selection, _value;

            _selection = selection.value();
            _value = value.value();
            if ((_selection != null) && _value) {
              _selection.text(_value);
            }
            return selection;
          }
        });
      },
      html: function(selection, value) {
        dvl.register({
          listen: [selection, value],
          fn: function() {
            var _selection, _value;

            _selection = selection.value();
            _value = value.value();
            if ((_selection != null) && _value) {
              _selection.html(_value);
            }
            return selection;
          }
        });
      },
      aLink: function(_arg) {
        var href;

        href = _arg.href;
        return function(selection, value) {
          return dvl.bind({
            parent: selection,
            self: 'a.link',
            attr: {
              href: href
            },
            text: value
          });
        };
      },
      img: function(selection, value) {
        return dvl.bind({
          parent: selection,
          self: 'img',
          attr: {
            src: value
          }
        });
      },
      imgDiv: function(selection, value) {
        return dvl.bind({
          parent: selection,
          self: 'div',
          attr: {
            "class": value
          }
        });
      },
      button: function(_arg) {
        var classStr, onObj;

        classStr = _arg.classStr, onObj = _arg.on;
        return function(selection, value) {
          return dvl.bind({
            parent: selection,
            self: 'button',
            attr: {
              "class": classStr
            },
            on: onObj,
            text: value
          });
        };
      },
      sparkline: function(_arg) {
        var height, padding, width, x, y;

        width = _arg.width, height = _arg.height, x = _arg.x, y = _arg.y, padding = _arg.padding;
        if (padding == null) {
          padding = 0;
        }
        return function(selection, value) {
          var dataFn, lineFn, svg;

          lineFn = dvl.apply({
            args: [x, y, padding],
            fn: function(x, y, padding) {
              return function(d) {
                var sx, sy;

                sx = d3.scale.linear().domain(d3.extent(d, function(d) {
                  return d[x];
                })).range([padding, width - padding]);
                sy = d3.scale.linear().domain(d3.extent(d, function(d) {
                  return d[y];
                })).range([height - padding, padding]);
                return d3.svg.line().x(function(dp) {
                  return sx(dp[x]);
                }).y(function(dp) {
                  return sy(dp[y]);
                })(d);
              };
            }
          });
          dataFn = dvl.apply({
            args: value,
            fn: function(value) {
              return function(d, i) {
                return [value(d, i)];
              };
            }
          });
          svg = dvl.bind({
            parent: selection,
            self: 'svg.sparkline',
            data: dataFn,
            attr: {
              width: width,
              height: height
            }
          });
          return dvl.bind({
            parent: svg,
            self: 'path',
            data: function(d) {
              return [d];
            },
            attr: {
              d: lineFn
            }
          });
        };
      }
    };
  })();

  (function() {
    var ajaxManagers, makeManager, nextGroupId, outstanding;

    outstanding = dvl(0).name('outstanding');
    ajaxManagers = [];
    makeManager = function() {
      var addHoock, getData, initRequestBundle, inputChange, makeRequest, maybeDone, nextQueryId, queries, worker;

      nextQueryId = 0;
      initRequestBundle = [];
      queries = [];
      maybeDone = dvl.group(function(requestBundle) {
        var notify, request, _i, _j, _len, _len1, _ref;

        for (_i = 0, _len = requestBundle.length; _i < _len; _i++) {
          request = requestBundle[_i];
          if (request.status !== 'ready') {
            return;
          }
        }
        notify = [];
        for (_j = 0, _len1 = requestBundle.length; _j < _len1; _j++) {
          request = requestBundle[_j];
          request.res.value((_ref = request.resVal) != null ? _ref : null);
          request.status = '';
          request.requestBundle = null;
          delete request.resVal;
        }
      });
      getData = function(request, query, err, resVal) {
        if (!request.requestBundle) {
          throw new Error("getData called outside of a request");
        }
        if (err) {
          request.resVal = null;
          if (request.onError) {
            request.onError(err);
          }
        } else {
          request.resVal = query ? resVal : null;
        }
        request.status = 'ready';
        delete request.curAjax;
        delete request.processResponce;
        maybeDone(request.requestBundle);
      };
      makeRequest = function(request) {
        var oldAjax, oldProcessResponce, processResponce, responceProcessed, _query;

        if (__indexOf.call(request.requestBundle, request) < 0) {
          throw new Error("invalid request");
        }
        _query = request.query.value();
        if (_query != null) {
          if (request.invalidOnLoad.value()) {
            request.res.value(null);
          }
          oldAjax = request.curAjax;
          oldProcessResponce = request.processResponce;
          responceProcessed = false;
          processResponce = function(err, data) {
            if (responceProcessed) {
              return;
            }
            responceProcessed = true;
            outstanding.value(outstanding.value() - 1);
            if (err === 'abort') {
              return;
            }
            getData(request, _query, err, data);
          };
          outstanding.value(outstanding.value() + 1);
          request.processResponce = processResponce;
          request.curAjax = request.requester(_query, processResponce);
          if (typeof oldProcessResponce === "function") {
            oldProcessResponce('abort');
          }
          if (oldAjax != null) {
            if (typeof oldAjax.abort === "function") {
              oldAjax.abort();
            }
          }
        } else {
          getData(request, _query, null, null);
        }
      };
      inputChange = function() {
        var makeRequestLater, newRequestBundle, q, _i, _j, _len, _len1;

        makeRequestLater = [];
        newRequestBundle = [];
        for (_i = 0, _len = queries.length; _i < _len; _i++) {
          q = queries[_i];
          if (!q.query.hasChanged()) {
            continue;
          }
          if (q.status === 'virgin') {
            if (q.query.value()) {
              initRequestBundle.push(q);
              q.status = 'requesting';
              q.requestBundle = initRequestBundle;
              makeRequestLater.push(q);
            } else {
              q.status = '';
            }
          } else {
            q.status = 'requesting';
            if (q.requestBundle) {
              delete q.resVal;
              makeRequestLater.push(q);
            } else {
              newRequestBundle.push(q);
              q.requestBundle = newRequestBundle;
              makeRequestLater.push(q);
            }
          }
        }
        for (_j = 0, _len1 = makeRequestLater.length; _j < _len1; _j++) {
          q = makeRequestLater[_j];
          makeRequest(q);
        }
      };
      worker = null;
      addHoock = function(query, ret) {
        if (worker) {
          worker.addListen(query);
          worker.addChange(ret);
        } else {
          worker = dvl.register({
            name: 'ajax_manager',
            listen: [query],
            change: [ret, outstanding],
            fn: inputChange
          });
        }
      };
      return function(query, invalidOnLoad, onError, requester, name) {
        var q, res;

        nextQueryId++;
        res = dvl().name(name);
        q = {
          id: nextQueryId,
          query: query,
          res: res,
          status: 'virgin',
          requester: requester,
          onError: onError,
          invalidOnLoad: invalidOnLoad,
          requestBundle: null,
          curAjax: null
        };
        queries.push(q);
        addHoock(query, res);
        return res;
      };
    };
    dvl.async = function(_arg) {
      var groupId, invalidOnLoad, name, onError, query, requester;

      query = _arg.query, invalidOnLoad = _arg.invalidOnLoad, onError = _arg.onError, groupId = _arg.groupId, requester = _arg.requester, name = _arg.name;
      if (!query) {
        throw 'it does not make sense to not have a query';
      }
      if (!requester) {
        throw 'it does not make sense to not have a requester';
      }
      if (typeof requester !== 'function') {
        throw 'requester must be a function';
      }
      query = dvl.wrap(query);
      invalidOnLoad = dvl.wrap(invalidOnLoad || false);
      name || (name = 'ajax_data');
      if (groupId == null) {
        groupId = dvl.async.getGroupId();
      }
      ajaxManagers[groupId] || (ajaxManagers[groupId] = makeManager());
      return ajaxManagers[groupId](query, invalidOnLoad, onError, requester, name);
    };
    dvl.async.outstanding = outstanding;
    nextGroupId = 0;
    dvl.async.getGroupId = function() {
      var id;

      id = nextGroupId;
      nextGroupId++;
      return id;
    };
  })();

  dvl.async.requester = {
    ajax: function(query, complete) {
      var abort, ajax;

      ajax = jQuery.ajax({
        url: query.url,
        data: query.dataFn ? query.dataFn(query.data) : query.data,
        type: query.method || 'GET',
        dataType: query.dataType || 'json',
        contentType: query.contentType || 'application/json',
        processData: query.processData || false,
        success: function(resVal) {
          if (query.fn) {
            resVal = query.fn(resVal, query);
          }
          ajax = null;
          complete(null, resVal);
        },
        error: function(xhr, textStatus) {
          ajax = null;
          complete(xhr.responseText || textStatus, null);
        }
      });
      abort = function() {
        if (ajax) {
          ajax.abort();
          ajax = null;
        }
      };
      return {
        abort: abort
      };
    },
    cacheWrap: function(_arg) {
      var cache, count, keyFn, max, requester, timeout, trim, _ref;

      _ref = _arg != null ? _arg : {}, requester = _ref.requester, max = _ref.max, timeout = _ref.timeout, keyFn = _ref.keyFn;
      if (!requester) {
        throw 'it does not make sense to not have a requester';
      }
      if (typeof requester !== 'function') {
        throw 'requester must be a function';
      }
      max = dvl.wrap(max || 100);
      timeout = dvl.wrap(timeout || 30 * 60 * 1000);
      cache = {};
      count = 0;
      keyFn || (keyFn = function(_arg1) {
        var contentType, data, dataType, method, processData, url;

        url = _arg1.url, data = _arg1.data, method = _arg1.method, dataType = _arg1.dataType, contentType = _arg1.contentType, processData = _arg1.processData;
        return [url, dvl.util.strObj(data), method, dataType, contentType, processData].join('@@');
      });
      trim = function() {
        var cutoff, d, m, newCache, oldestQuery, oldestTime, q, tout, _results;

        tout = timeout.value();
        if (tout > 0) {
          cutoff = Date.now() - tout;
          newCache = {};
          for (q in cache) {
            d = cache[q];
            if (cutoff < d.time) {
              newCache[q] = d;
            }
          }
          cache = newCache;
        }
        m = max.value();
        _results = [];
        while (m < count) {
          oldestQuery = null;
          oldestTime = Infinity;
          for (q in cache) {
            d = cache[q];
            if (d.time < oldestTime) {
              oldestTime = d.time;
              oldestQuery = q;
            }
          }
          delete cache[oldestQuery];
          _results.push(count--);
        }
        return _results;
      };
      dvl.register({
        listen: [max, timeout],
        fn: trim
      });
      return {
        clear: function() {
          cache = {};
          count = 0;
        },
        requester: function(query, complete) {
          var abort, added, c, key;

          key = keyFn(query);
          c = cache[key];
          added = false;
          if (!c) {
            cache[key] = c = {
              time: Date.now(),
              waiting: [complete]
            };
            added = true;
            count++;
            trim();
            c.ajax = requester(query, function(err, resVal) {
              var cb, _i, _j, _len, _len1, _ref1, _ref2;

              if (err) {
                if (err === "abort") {
                  return;
                }
                c.ajax = null;
                delete cache[key];
                count--;
                _ref1 = c.waiting;
                for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
                  cb = _ref1[_i];
                  cb(err, null);
                }
                delete c.waiting;
                return;
              }
              c.ajax = null;
              c.resVal = resVal;
              _ref2 = c.waiting;
              for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
                cb = _ref2[_j];
                cb(null, resVal);
              }
              delete c.waiting;
            });
          }
          if (c.resVal) {
            complete(null, c.resVal);
            abort = function() {};
          } else {
            if (!added) {
              c.waiting.push(complete);
            }
            abort = function() {
              if (!c.waiting) {
                return;
              }
              c.waiting = c.waiting.filter(function(l) {
                return l !== complete;
              });
              complete('abort', null);
              if (c.waiting.length === 0 && c.ajax) {
                c.ajax.abort();
                c.ajax = null;
                delete cache[key];
                count--;
              }
            };
          }
          return {
            abort: abort
          };
        }
      };
    }
  };

}).call(this);
