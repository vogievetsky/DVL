<!DOCTYPE html>
<html>
	<head>
		<title>DVL: Data Visualization Legos Walkthrough</title>
		<link rel="stylesheet" href="tutorial.css"></link>
		<script src="d3.v3.min.js"></script>
		<script src="../dvl.js"></script>    
	</head>
	<body>
    <h1 id="title">Data Visualization Legos: A Walkthrough</h1>

    <hr>

    <h2>Contents</h2>
      <ol>
        <li>Motivations</li>
        <li>Examples</li>
        <li>Technical Overview</li>
        <li>A Simple Example Decomposed</li>
        <li>Creating DVL Variables</li>
        <li>Types of Apply Functions</li>
        <li>'bind' and 'register'</li>
        <li>Error-spotting?</li>
      </ol>

    <hr/>

    <h2>Motivations</h2>
    <p>What is DVL and why would I want to use it?</p>

    <p>DVL (Data Visualization Legos) reduces the effort of creating data visualizations of real-time data in the browser. You specify the data and a directed acyclic graph. When the data is updated, only those functions dependent on the changed data are updated. Essentially, you model the data flow and then spend your time working with the data.</p>

    <hr>

    <h2>Examples</h2>
    <p class="todo">Example 1</p>
    <p class="todo">Example 2</p>
    <p class="todo">Example 3</p>

    <hr>

    <h2>Technical Overview</h2>

    <hr>

    <h2>A Simple Example Decomposed</h2>

    <p>Here we create a variable and set up an HTML element to update whenever the variable is altered.</p>

    <div id="ex01"></div>
  <script src="example01.js"></script>
  <!-- TODO: figure out why this example doesn't run if other scripts are executed. -->

  <p>Let's walk through the code.</p>

    <code>
      <pre>
var coord = dvl(0);

setInterval(function() {
  coord.value(coord.value() + 0.01);
}, 500);

dvl.bindSingle({
  self: d3.select('div#ex01'),
  text: coord
})
    </pre>
  </code>


  <ol>
    <li>First, we create a variable. Notice the variable is wrapped in the dvl() function.
    Doing this enables the variable to send a message when its value has altered.</li>
    <li>Next we alter the data stored in the coord variable.</li>
    <li>Next we select the div HTML element with the "ex01" id and tell it to update it's text value whenever
    the coord variable changes.</li>
  </ol>

  <p>The text will only update when the coord value is updated. Setting up a data flow and then concerning yourself only with handling the data is a key philosophy of DVL.</p>

  <p>Notice how we've used a D3 method to select the HTML element to bind. DVL is designed to work well with <a href="http://www.d3js.org">D3</a>.</p>

  <h2>Using Multiple Values With DVL</h2>

  <p>We'll usually want to visualize multiple variables, so let's make example 01 multivariate. First, a few alterations to the single-variate case:</p>

  <div id="ex02"></div>
  <script src="example02.js"></script>

  <p>Let's look at the lines changed from example 01.</p>

  <code>
    <pre>
var coord = dvl(0);

setInterval(function() {
  coord.value(coord.value() + 0.01);
}, 500);

var coords = dvl.apply(coord, function(d) {
  return [d];})

dvl.bind({
  parent: d3.select('div#ex02'),
  self: 'p.output',
  data: coords,
  text: String
});      
    </pre>
  </code>

<p>Notice the addition of the 'dvl.apply' function. This function will be explained more in depth later, but for the moment just notice that it performs a transformation on the dvl variable we provide as input. In this case, we take the DVL variable 'coord' and return it as a single-element array. DVL expects arrays. (We actually did provide DVL with an array in example 01. We just used the convenience function dvl.bindSingle to do so.)</p>

<p>Next, notice 'dvl.bindSingle' has been replaced with the more general 'dvl.bind', which you will likely use more often. In addition, we are now binding the DVL variable through the 'data' property. This allows us to specify a function on the data prior to displaying as text. In this example, we simple convert the value of the DVL variable to text with no modifications. However, we can replace the line

  <code>
    <pre>
  text: String
    </pre>
  </code>

with

  <code>
    <pre>
  text: function(x) { return x.toFixed(2); }    
    </pre>
  </code>

which formats the number to two decimal places. Since it is just a function, you can also--for example--use this transformation function to provide animations when data changes.</p>

<p>Now let's add another variable to the example. To do so, we create another DVL variable, set it to update, and combine it into a list with the previously existing DVL variable:</p>

<code>
  <pre>
var coord1 = dvl(0);
var coord2 = dvl(1);

setInterval(function() {
  coord1.value(coord.value() + 0.01);
  coord2.value(coord2.value() + 0.02);
}, 500);

var coords = dvl.apply([coord1, coord2], function(_coord1, _coord2) {
  return [_coord1, _coord2];
});

dvl.bind({
  parent: d3.select('div#ex03'),
  self: 'p.output',
  data: coords,
  text: function(x) { return x.toFixed(2); }
});
  </pre>
</code>

<div id="ex03"></div>
<script src="example03.js"></script>

<p>Notice how DVL has now auto-created two HTML elements. If not present, DVL will create needed HTML elements. This is similar to how <a href="http://www.d3js.org">D3</a> operates.</p>

<p>More subtle, notice how we've used '_coord1' and '_coord2' as the internal variable names in the call to dvl.apply. Every DVL variable is an object that stores its value as a property. dvl.apply passes the actual value, and we use the underscore convention to make this practice more explicit.</p>

<P>It's also worth mentioning that the line

<code>
  <pre>
var coords = dvl.apply([coord1, coord2], function(_coord1, _coord2) {
  return [_coord1, _coord2];
});
  </pre>
</code>

can be more succinctly written as
<code>
  <pre>
var coords = dvl.op.list(coord1, coord2);
  </pre>
</code>

We'll look at the types of convenience functions DVL has later in the walkthrough.
</p>


<p>Now that we have a simple DVL pipeline set up, let's create a more graphical representation of the coordinates. To do so, we'll start to manipulate HTML and CSS attributes. First we'll add styling for a CSS 'racer' class:

<code>
  <pre>
.racer {
  position: relative;
  width: 50px;
  text-align: center;
  padding: 0.1em;
  background-color: blue;
  color: white;
}
  </pre>
</code>

Then we'll extend our above JavaScript example to include a randomized increase to each coordinate. The primary change we'll add is a function to the "style" property of the object we pass into the call to dvl.apply. Since the 'coords' data we're specified is multivariate, the function we've added will be called once for each variable in coords.

<code>
  <pre>
var coordBall1 = dvl(0);
var coordBall2 = dvl(0);

var speed1 = Math.random() * 10 + 1;
var speed2 = Math.random() * 10 + 1;

var maxMovement = 150;
setInterval(function() {
  var newCoord1 = coordBall1.value() + speed1;
  var newCoord2 = coordBall2.value() + speed2;
  var checkBounds = function(x) { if (x > maxMovement) x = 0; return x;};
  newCoord1 = checkBounds(newCoord1);
  newCoord2 = checkBounds(newCoord2);

  coordBall1.value(newCoord1);
  coordBall2.value(newCoord2);
}, 250);

var coords = dvl.op.list(coordBall1, coordBall2);

dvl.bind({
  parent: d3.select("div#ballRace"),
  self: "div.racer",
  data: coords,
  style: {left: function (x) {
    return x + "px";}
  },
  text: function(x) { return x.toFixed(2); }
})

  </pre>
</code>

These changes give us:

<div id="divRace"></div>
<script src="divRace.js"></script>

</p>
<!-- ************************************** -->
  <hr>
  <h2>Tidbits</h2>
  <ul>
    <li>dvl.debug('coord', coord)</li>
    <li>How DVL differs from backbone.js</li>
  </ul>

<!-- ************************************** -->
  <hr>
  <h2>Debug Practice</h2>

	</body>
</html>
