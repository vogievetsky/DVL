<!DOCTYPE html>
<html>
	<head>
		<title>DVL: Data Visualization Legos Walkthrough</title>
		<link rel="stylesheet" href="tutorial.css"></link>
		<script src="d3.v3.min.js"></script>
		<script src="../dvl.js"></script>    
	</head>
	<body>
    <h1 id="title">Data Visualization Legos: A Walkthrough</h1>

    <hr>

    <h2>Contents</h2>
      <ol>
        <li>Motivations</li>
        <li>Examples</li>
        <li>Things You Should Know Before Jumping In</li>
        <li>Technical Overview</li>
        <li>A Simple Example Decomposed</li>
        <li>Creating DVL Variables</li>
        <li>Types of Apply Functions</li>
        <li>'bind' and 'register'</li>
        <li>Simulating Data</li>
        <li>Error-spotting?</li>
      </ol>

    <hr/>

    <h2>Motivations</h2>
    <p>What is DVL and why would I want to use it?</p>

    <p>DVL (Data Visualization Legos) reduces the effort of creating data visualizations of real-time data in the browser. You specify the data and a pipeline that leads from the data to visualization components. When the data is updated, only the components dependent on the data values that were changed are updated. Essentially, you model the data flow and then spend your time working with the data.</p>

    <p>DVL also provide a set of visualization and interaction components along with conveniences for tying them to update on data changes.</p>

    <hr>

    <h2>Things You Should Know Before DVL</h2>
    <ul>
      <li>Enough JavaScript to traverse the HTML DOM, modify elements, etc.</li>
      <li>Basic CSS</li>
      <li>A fair amount of <a href="http://d3js.org">D3</a>. DVL is a layer on top of D3. If you can look at <a href="randomBarChartWithD3.html">this interactive plot</a> and think of how to implement it using D3, you should be OK.</li>
    </ul>

    <hr>
    <h2>Examples</h2>
    <p class="todo">Real-Time Bar Chart</p>
    <p class="todo">Axes That Auto-Scale with Real-Time Data</p>
    <p class="todo">Dropdown List wth Autocomplete</p>


    <hr>
    <h2>Technical Overview</h2>

    <p>To set up a DVL application, you create a set of pipes. These pipes start at data, pass through functions, and tell visual components to update. This is essentially a model/view/controller (MVC) system. For a reference point, Backbone.js can be considered similar to DVL. However, DVL is targeted for the case of data visualizations on real-time data. It offers two advantages over a standard MVC framework:</p>

    <ul>
      <li>Once placed in the pipeline, DVL's components will not update until they have received messages from all upstream data sources the component depends on.  For example, if new data was added to a dataset being visualized with a chart, the x and y axes of the chart would scale at the same time. (TODO: place in deep-geek section: DVL accomplishes this by ordering messages using a topological sort.)</li>
      <li>Visualization and interaction components designed to drop into a DVL pipeline.
    </ul>

    <hr>

    <h2>A Simple Example Explained: Tell DVL to Update Text When a Variable Changes</h2>

    <p>Here we create a variable and set up an HTML element to update whenever the variable is altered.</p>

    <div id="ex01"></div>
  <script src="example01.js"></script>
  <!-- TODO: figure out why this example doesn't run if other scripts are executed. -->

  <p>Let's walk through the code.</p>

    <code>
      <pre>
var coord = dvl(0);

setInterval(function() {
  coord.value(coord.value() + 0.01);
}, 500);

dvl.bindSingle({
  self: d3.select('div#ex01'),
  text: coord
})
    </pre>
  </code>


  <ol>
    <li>First, we create a variable. Notice the variable is wrapped in the dvl() function.
    Doing this enables the variable to send a message when its value has altered.</li>
    <li>Next we alter the data stored in the coord variable.</li>
    <li>Next we select the div HTML element with the "ex01" id and tell it to update it's text value whenever
    the coord variable changes.</li>
  </ol>

  <p>The text will only update when the coord value is updated. Setting up a data flow and then concerning yourself only with handling the data is a key philosophy of DVL.</p>

  <p>Notice how we've used a D3 method to select the HTML element to bind. DVL is designed to work well with <a href="http://www.d3js.org">D3</a>.</p>

  <h2>Using Multiple Values With DVL</h2>

  <p>We'll usually want to visualize multiple variables, so let's make example 01 multivariate. First, a few alterations to the single-variate case:</p>

  <div id="ex02"></div>
  <script src="example02.js"></script>

  <p>Let's look at the lines changed from example 01.</p>

  <code>
    <pre>
var coord = dvl(0);

setInterval(function() {
  coord.value(coord.value() + 0.01);
}, 500);

var coords = dvl.apply(coord, function(d) {
  return [d];})

dvl.bind({
  parent: d3.select('div#ex02'),
  self: 'p.output',
  data: coords,
  text: String
});      
    </pre>
  </code>

<p>Notice the addition of the 'dvl.apply' function. This function will be explained more in depth later, but for the moment just notice that it performs a transformation on the DVL variable we provide as input. In this case, we take the DVL variable 'coord' and return it as a single-element array. DVL expects arrays. (We actually did provide DVL with an array in example 01. We just used the convenience function dvl.bindSingle to do so.)</p>

<p>Next, notice 'dvl.bindSingle' has been replaced with the more general 'dvl.bind', which you will likely use more often. In addition, we are now binding the DVL variable through the 'data' property. This allows us to specify a function on the data prior to displaying as text. In this example, we simple convert the value of the DVL variable to text with no modifications. However, we can replace the line

  <code>
    <pre>
  text: String
    </pre>
  </code>

with

  <code>
    <pre>
  text: function(x) { return x.toFixed(2); }    
    </pre>
  </code>

which formats the number to two decimal places. Since it is just a function, you can also--for example--use this transformation function to provide animations when data changes.</p>

<p>Now let's add another variable to the example. To do so, we create another DVL variable, set it to update, and combine it into a list with the previously existing DVL variable:</p>

<code>
  <pre>
var coord1 = dvl(0);
var coord2 = dvl(1);

setInterval(function() {
  coord1.value(coord.value() + 0.01);
  coord2.value(coord2.value() + 0.02);
}, 500);

var coords = dvl.apply([coord1, coord2], function(_coord1, _coord2) {
  return [_coord1, _coord2];
});

dvl.bind({
  parent: d3.select('div#ex03'),
  self: 'p.output',
  data: coords,
  text: function(x) { return x.toFixed(2); }
});
  </pre>
</code>

<div id="ex03"></div>
<script src="example03.js"></script>

<p>Notice how DVL has now auto-created two HTML elements. If not present, DVL will create needed HTML elements. This is similar to how <a href="http://www.d3js.org">D3</a> operates.</p>

<p>More subtle, notice how we've used '_coord1' and '_coord2' as the internal variable names in the call to dvl.apply. Every DVL variable is an object that stores its value as a property. dvl.apply passes the actual value, and we use the underscore convention to make this practice more explicit.</p>

<P>It's also worth mentioning that the line

<code>
  <pre>
var coords = dvl.apply([coord1, coord2], function(_coord1, _coord2) {
  return [_coord1, _coord2];
});
  </pre>
</code>

can be more succinctly written as
<code>
  <pre>
var coords = dvl.op.list(coord1, coord2);
  </pre>
</code>

We'll look at the types of convenience functions DVL has later in the walkthrough.
</p>


<p>Now that we have a simple DVL pipeline set up, let's create a more graphical representation of the coordinates. To do so, we'll start to manipulate HTML and CSS attributes. First we'll add styling for a CSS 'racer' class:

<code>
  <pre>
.racer {
  position: relative;
  width: 50px;
  text-align: center;
  padding: 0.1em;
  background-color: blue;
  color: white;
}
  </pre>
</code>

Then we'll extend our above JavaScript example to include a randomized increase to each coordinate. The primary change we'll add is a function to the "style" property of the object we pass into the call to dvl.apply. Since the 'coords' data we're specified is multivariate, the function we've added will be called once for each variable in coords.

<code>
  <pre>
var coordBall1 = dvl(0);
var coordBall2 = dvl(0);

var speed1 = Math.random() * 10 + 1;
var speed2 = Math.random() * 10 + 1;

var maxMovement = 150;
setInterval(function() {
  var newCoord1 = coordBall1.value() + speed1;
  var newCoord2 = coordBall2.value() + speed2;
  var checkBounds = function(x) { if (x > maxMovement) x = 0; return x;};
  newCoord1 = checkBounds(newCoord1);
  newCoord2 = checkBounds(newCoord2);

  coordBall1.value(newCoord1);
  coordBall2.value(newCoord2);
}, 250);

var coords = dvl.op.list(coordBall1, coordBall2);

dvl.bind({
  parent: d3.select("div#ballRace"),
  self: "div.racer",
  data: coords,
  style: {left: function (x) {
    return x + "px";}
  },
  text: function(x) { return x.toFixed(2); }
})

  </pre>
</code>

These changes give us:

<div id="divRace"></div>
<script src="divRace.js"></script>
</p>

<p>We now have the tools to create a <a href="realTimeBarChart.html">real-time bar chart</a>.</p>

<p> Notice the initial line of the script:

  <code>
    <pre>
var coords = dvl([0, 0, 0, 0, 0, 0, 0, 0, 0, 0]).compare(false);
    </pre>
  </code>

DVL will compare values in a DVL variable prior to letting any dependencies know to update. If a value has not been changed, DVL will not send an update message. In the case of arrays, we must overwrite the default comparison operator. Why?  Let's take a look at the default comparison, which for the variable 'coords' would be the following:

<code>
  <pre>
var coords = dvl([0, 0]).compare(function(a, b) { return a === b});
  </pre>
</code>

In the case of 'coords', we are comparing a pointer to a pointer. Even though the data in memory has changed, the pointer value has not, the comparison function returns 'true', and DVL does not issue an update message.
</p>

<p>For clarity, another solution would be to create a new array when the data is updated:

<code>
  <pre>
setInterval(function() {
  _coordArray = coordArray.value();
  _coordArray[0] = _coordArray[0] + 0.1;
  coordArray.value(_coordArray.slice());
}, 500);
  </pre>
</code>

</p>

<hr>
<h2>Exercise</h2>
<p>To get used to DVL's documentation, try to remove the explicit overwrite of the comparison function in the real-time bar chart. Instead, use dvl.notify();</p>

<p>Solution:

  <code>
    <pre>
var data = dvl([2, 6, 8, 3, 2]);

setInterval(function() {
  var _data = data.get();
  _data.shift()
  _data.push(Math.round(Math.random() * 9 + 1))
  _data;
  data.set(_data).notify();
}, 1000);    </pre>
  </code>

</p>

<hr>
<h2>Axes That Auto-Scale with Real-Time Data</h2>

<p>If the real-time bar chart from section TODO runs long enough, it will grow outside of the page's visible area. One approach to fix this is to introduce auto-scaling axes. In <a href="autoscalingAxes.html">this section</a> we'll walk through how to accomplish this.</p>

<hr>
<h2>Simulating Data</h2>
<code>
  <pre>
    dvl.random(); dvl.record();
  </pre>

<p>The real-time bar chart used a very basic technique for simulating data. In this section, we'll look at the capabilities DVL has for simulating real-time data. TODO: deconstruct the random-walk example.

</code>

<hr>
<h2>Manipulating the DOM with DVL</h2>
DVL can be used to manipulate the DOM aside from creating a data-visualization pipeline:

<code>
  <pre>
    var pParent = d3.select("body").append("div.parent");

    var clearButton = dvl.bindSingle({
      parent: buttonParent,
      self: "p",
      text: "A p element created with DVL"
    });
  </pre>
</code>

"clearButton" will now be a DVL variable. You can get its D3 selection as follows:

<code>
  <pre>
    var d3Selection = clearButton.value();    
  </pre>
</code>


<hr>
<h2>Creating GUI Components with DVL</h2>

<a href="creatingGUIComponents.html">Link</a>

<hr>
<h2>DVL Register</h2>

<p>So far we've been binding data to visualizations using dvl.bind, dvl.bindSingle, etc.  Now let's look deeper at how they set up the DVL pipeline and look at some examples.</p>

<p>dvl.bind, dvl.bindSingle, and other helper functions make a call to dvl.register.  Let's take a look at a basic usage of it:

<code>
  <pre>
    dvl.register({
      listen: data,
      change: output,
      fn: //do some funciton
  });
  </pre>
</code>
</p>


TODO: swap out dvl.bindSingle in initial example with dvl.register()

<hr>
<h2>dvl.applyAlways and "null"</h2>

TODO: drop in the bug I had where I used dvl.apply instead of dvl.applyAlways

<hr>
<h2>Accessors</h2>
TODO: write this section once Vad shows me how to add accessors.

<!-- ************************************** -->
  <hr>
  <h2>Tidbits</h2>
  <ul>
    <li>dvl.debug('coord', coord)</li>
    <li>How DVL differs from backbone.js</li>
  </ul>

  <p>You don't have to select a pre-existing HTML element to bind it. It will be creating during the bind (similar to D3):

    <code>
      <pre>

var coord = dvl(0);

setInterval(function() {
  coord.value(coord.value() + 0.01);
}, 500);

dvl.bindSingle({
  parent: d3.select('#anExample'),
  self: "div.test",
  text: coord
});

      </pre>
    </code>



  </p>

<!-- ************************************** -->
  <hr>
  <h2>Debug Practice</h2>

	</body>
</html>
